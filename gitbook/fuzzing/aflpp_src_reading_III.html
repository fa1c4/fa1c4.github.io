
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>AFLpp Src Reading III - Instrumentation Â· FA1C4 PATHs</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="fa1c4">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-toggle-chapters/toggle.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="aflpp_new_test.html" />
    
    
    <link rel="prev" href="aflpp_src_reading_II.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../papers/">
            
                <a href="../papers/">
            
                    
                    Papers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../papers/SoK_Prudent_Evaluation_Practices_for_Fuzzing.html">
            
                <a href="../papers/SoK_Prudent_Evaluation_Practices_for_Fuzzing.html">
            
                    
                    SoK: Prudent Evaluation Practices for Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../papers/FOX.html">
            
                <a href="../papers/FOX.html">
            
                    
                    FOX: Coverage-guided Fuzzing as Online Stochastic Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../papers/On_Understanding.html">
            
                <a href="../papers/On_Understanding.html">
            
                    
                    On Understanding and Forecasting Fuzzers Performance with Static Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../papers/autofz.html">
            
                <a href="../papers/autofz.html">
            
                    
                    autofz: Automated Fuzzer Composition at Runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../papers/Fuzz_to_the_Future.html">
            
                <a href="../papers/Fuzz_to_the_Future.html">
            
                    
                    Fuzz to the Future: Uncovering Occluded Future Vulnerabilities via Robust Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../papers/DSFuzz.html">
            
                <a href="../papers/DSFuzz.html">
            
                    
                    DSFuzz: Detecting Deep State Bugs with Dependent State Exploration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../papers/Rubick.html">
            
                <a href="../papers/Rubick.html">
            
                    
                    Automata-Guided Control-Flow-Sensitive Fuzz Driver Generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../papers/Fuzz4All.html">
            
                <a href="../papers/Fuzz4All.html">
            
                    
                    Fuzz4All: Universal Fuzzing with Large Language Models
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../papers/kag.html">
            
                <a href="../papers/kag.html">
            
                    
                    KAG: Boosting LLMs in Professional Domains via Knowledge Augmented Generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../papers/graphuzz.html">
            
                <a href="../papers/graphuzz.html">
            
                    
                    Graphuzz: Data-driven Seed Scheduling for Coverage-guided Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="../papers/Seed_Selection.html">
            
                <a href="../papers/Seed_Selection.html">
            
                    
                    Seed Selection for Successful Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="../papers/belieffuzz.html">
            
                <a href="../papers/belieffuzz.html">
            
                    
                    Balance Seed Scheduling via Monte Carlo Planning
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="../papers/K_Scheduler.html">
            
                <a href="../papers/K_Scheduler.html">
            
                    
                    Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="../papers/entropic.html">
            
                <a href="../papers/entropic.html">
            
                    
                    Boosting Fuzzer Efficiency: An Information Theoretic Perspective
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="../papers/FuzzInMem.html">
            
                <a href="../papers/FuzzInMem.html">
            
                    
                    FuzzInMem: Fuzzing Programs via In-memory Structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="../papers/AFLpp.html">
            
                <a href="../papers/AFLpp.html">
            
                    
                    AFL++: Combining Incremental Steps of Fuzzing Research
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="../papers/DDFuzz.html">
            
                <a href="../papers/DDFuzz.html">
            
                    
                    Fuzzing with Data Dependency Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.18" data-path="../papers/Hier.html">
            
                <a href="../papers/Hier.html">
            
                    
                    Reinforcement Learning-based Hierarchical Seed Scheduling for Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.19" data-path="../papers/LLM_Fuzzing_BusyBox.html">
            
                <a href="../papers/LLM_Fuzzing_BusyBox.html">
            
                    
                    Fuzzing BusyBox: Leveraging LLM and Crash Reuse for Embedded Bug Unearthing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.20" data-path="../papers/llm2vec.html">
            
                <a href="../papers/llm2vec.html">
            
                    
                    LLM2Vec: Large Language Models Are Secretly Powerful Text Encoders
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.21" data-path="../papers/ShapFuzz.html">
            
                <a href="../papers/ShapFuzz.html">
            
                    
                    SHAPFUZZ: Efficient Fuzzing via Shapley-Guided Byte Selection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.22" data-path="../papers/TortoiseFuzz.html">
            
                <a href="../papers/TortoiseFuzz.html">
            
                    
                    Not All Coverage Measurements Are Equal: Fuzzing by Coverage Accounting for Input Prioritization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.23" data-path="../papers/prefix_guided_execution.html">
            
                <a href="../papers/prefix_guided_execution.html">
            
                    
                    Accelerating Fuzzing through Prefix-Guided Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.24" data-path="../papers/Fuzztastic.html">
            
                <a href="../papers/Fuzztastic.html">
            
                    
                    Extrapolating Coverage Rate in Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.25" data-path="../papers/ProRec.html">
            
                <a href="../papers/ProRec.html">
            
                    
                    Source Code Foundation Models are Transferable Binary Analysis Knowledge Bases
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.26" data-path="../papers/Coding-PTMs.html">
            
                <a href="../papers/Coding-PTMs.html">
            
                    
                    Coding-PTMs: How to Find Optimal Code Pre-trained Models for Code Embedding in Vulnerability Detection?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.27" data-path="../papers/AFGEN.html">
            
                <a href="../papers/AFGEN.html">
            
                    
                    AFGEN: Whole-Function Fuzzing for Applications and Libraries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.28" data-path="../papers/Arbiter.html">
            
                <a href="../papers/Arbiter.html">
            
                    
                    Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.29" data-path="../papers/SecureFalcon.html">
            
                <a href="../papers/SecureFalcon.html">
            
                    
                    SecureFalcon: Are We There Yet in Automated Software Vulnerability Detection With LLMs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.30" data-path="../papers/VFFinder.html">
            
                <a href="../papers/VFFinder.html">
            
                    
                    Effective Vulnerable Function Identification based on CVE Description Empowered by Large Language Models
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.31" data-path="../papers/patch_evolution.html">
            
                <a href="../papers/patch_evolution.html">
            
                    
                    Unveiling the Characteristics and Impact of Security Patch Evolution
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../linux/">
            
                <a href="../linux/">
            
                    
                    Linux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../linux/rust_elementary_I.html">
            
                <a href="../linux/rust_elementary_I.html">
            
                    
                    Rust Elementary I
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../linux/rust_elementary_II.html">
            
                <a href="../linux/rust_elementary_II.html">
            
                    
                    Rust Elementary II
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../linux/rust_elementary_III.html">
            
                <a href="../linux/rust_elementary_III.html">
            
                    
                    Rust Elementary III
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="../linux/rust_elementary_IV.html">
            
                <a href="../linux/rust_elementary_IV.html">
            
                    
                    Rust Elementary IV
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="../linux/rust_elementary_V.html">
            
                <a href="../linux/rust_elementary_V.html">
            
                    
                    Rust Elementary V
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="../linux/rust_elementary_VI.html">
            
                <a href="../linux/rust_elementary_VI.html">
            
                    
                    Rust Elementary VI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.7" data-path="../linux/docker_sources_switch.html">
            
                <a href="../linux/docker_sources_switch.html">
            
                    
                    Docker Sources Switch
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="./">
            
                <a href="./">
            
                    
                    Fuzzing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="AFLpp_build_on_Magma.html">
            
                <a href="AFLpp_build_on_Magma.html">
            
                    
                    AFLpp build for Magma
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="fuzzbench_build.html">
            
                <a href="fuzzbench_build.html">
            
                    
                    FuzzBench Build
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="fuzzbench_new_fuzzer.html">
            
                <a href="fuzzbench_new_fuzzer.html">
            
                    
                    Fuzzbench new Fuzzer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="aflpp_src_reading_I.html">
            
                <a href="aflpp_src_reading_I.html">
            
                    
                    AFLpp Src Reading I - History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="aflpp_src_reading_II.html">
            
                <a href="aflpp_src_reading_II.html">
            
                    
                    AFLpp Src Reading II - Forkserver
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.1.6" data-path="aflpp_src_reading_III.html">
            
                <a href="aflpp_src_reading_III.html">
            
                    
                    AFLpp Src Reading III - Instrumentation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.7" data-path="aflpp_new_test.html">
            
                <a href="aflpp_new_test.html">
            
                    
                    AFL++ Add New Test
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.8" data-path="aflpp_custom_mutator.html">
            
                <a href="aflpp_custom_mutator.html">
            
                    
                    AFL++ Custom Mutator (python)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../pwn/">
            
                <a href="../pwn/">
            
                    
                    Pwn
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../pwn/glibc_IO_FILE_exploitation.html">
            
                <a href="../pwn/glibc_IO_FILE_exploitation.html">
            
                    
                    Glibc _IO_FILE Exploitation Introduction
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../reverse/">
            
                <a href="../reverse/">
            
                    
                    Reverse
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" data-path="../reverse/IDAPro_cheatsheet_7x.html">
            
                <a href="../reverse/IDAPro_cheatsheet_7x.html">
            
                    
                    IDAPro Cheat Sheet 7.7
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../theory/">
            
                <a href="../theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../theory/prac_statistics.html">
            
                <a href="../theory/prac_statistics.html">
            
                    
                    Practical Statistics
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../LLM/">
            
                <a href="../LLM/">
            
                    
                    LLM
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" data-path="../latex/">
            
                <a href="../latex/">
            
                    
                    Latex
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" data-path="../latex/awes_table.html">
            
                <a href="../latex/awes_table.html">
            
                    
                    latex awesome table templates
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="9.1" data-path="../shell/">
            
                <a href="../shell/">
            
                    
                    Shell
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="9.1.1" data-path="../shell/shell_programming_basic.html">
            
                <a href="../shell/shell_programming_basic.html">
            
                    
                    shell programming basic
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.2" data-path="../shell/shell_programming_techs_I.html">
            
                <a href="../shell/shell_programming_techs_I.html">
            
                    
                    shell programming techs I
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >AFLpp Src Reading III - Instrumentation</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="afl-source-code-reading-iii---instrumentation">AFL++ Source Code Reading III - Instrumentation</h1>
<p>&#x672C;&#x6587;&#x89E3;&#x6790; AFL++ &#x63D2;&#x6869;&#x90E8;&#x5206;&#x7684;&#x6E90;&#x4EE3;&#x7801;</p>
<p>AFL++ &#x4ECE; 3.00c &#x7248;&#x672C;&#x5F00;&#x59CB;&#x7EDF;&#x4E00;&#x6240;&#x6709;&#x63D2;&#x6869;&#x7F16;&#x8BD1;&#x5668;&#x5230; <code>afl-cc</code>, &#x867D;&#x7136;&#x7F16;&#x8BD1; AFL++ &#x4E4B;&#x540E;&#x4F9D;&#x7136;&#x6709; <code>afl-clang*</code> &#x4E4B;&#x7C7B;&#x7684;&#x7F16;&#x8BD1;&#x5668;, &#x4F46;&#x90FD;&#x662F;&#x94FE;&#x63A5;&#x5230; <code>afl-cc</code> &#x7684;&#x94FE;&#x63A5;&#x6587;&#x4EF6;, &#x5B9E;&#x9645;&#x8C03;&#x7528;&#x7684;&#x90FD;&#x662F; <code>afl-cc</code>. AFL++ &#x652F;&#x6301;&#x7684;&#x63D2;&#x6869;&#x65B9;&#x5F0F;&#x5F88;&#x591A;, &#x672C;&#x7BC7;&#x4E3B;&#x8981;&#x5173;&#x6CE8; llvm mode. </p>
<h2 id="overview">Overview</h2>
<p>AFL++ &#x652F;&#x6301;&#x7684;&#x63D2;&#x6869;&#x9009;&#x62E9;&#x5982;&#x4E0B;</p>
<table>
<thead>
<tr>
<th>Instrumentation</th>
<th>Desription</th>
</tr>
</thead>
<tbody>
<tr>
<td>CmpLog</td>
<td>Enables logging of comparison operands in a shared memory. Used by various mutators, like redqueen [2].</td>
</tr>
<tr>
<td>GCC-based</td>
<td><code>afl-gcc-fast</code> and <code>afl-g++-fast</code>. True compiler-level instrumentation.</td>
</tr>
<tr>
<td>Injection</td>
<td>Proof-of-concept implementation to additionally hunt for injection vulnerabilities. It works by instrumenting calls to specific functions and parsing the query parameter for a specific unescaped dictionary string, and if detected, crashes the target.</td>
</tr>
<tr>
<td>Partial Instrumentation</td>
<td>Testing complex programs where only a part of the program is the fuzzing target, it often helps to only instrument the necessary parts of the program, leaving the rest uninstrumented.</td>
</tr>
<tr>
<td>laf-intel</td>
<td>Make some code transformations that help AFL++ to enter conditional blocks, where conditions consist of comparisons of large values.</td>
</tr>
<tr>
<td>Fast LLVM-based</td>
<td><code>afl-clang-fast</code> and <code>afl-clang-fast++</code>. True compiler-level instrumentation. Requires llvm-3.8 up to 17.</td>
</tr>
<tr>
<td>lto</td>
<td>Collision free instrumentation and is faster than PCGUARD. Requires LLVM 12+.</td>
</tr>
<tr>
<td>persistent mode</td>
<td>AFL++ fuzzes a target multiple times in a single forked process, instead of forking a new process for each fuzz execution. Persistent mode requires that the target can be called in one or more functions, and that its state can be completely reset so that multiple calls can be performed without resource leaks, and that earlier runs will have no impact on future runs.</td>
</tr>
</tbody>
</table>
<p>llvm mode &#x7684;&#x6838;&#x5FC3;&#x6E90;&#x6587;&#x4EF6;</p>
<ul>
<li><strong>afl-llvm-common.*</strong>: LLVM &#x63D2;&#x6869;&#x7684;&#x516C;&#x5171;&#x8F85;&#x52A9;&#x4EE3;&#x7801;, &#x5C01;&#x88C5;&#x591A;&#x4E2A;&#x63D2;&#x6869; Pass &#x5171;&#x7528;&#x7684;&#x51FD;&#x6570;&#x548C;&#x6570;&#x636E;&#x7ED3;&#x6784;, &#x6BD4;&#x5982;&#x63D2;&#x6869;&#x70B9;&#x7BA1;&#x7406;&#x3001;&#x8F85;&#x52A9;&#x5DE5;&#x5177;&#x51FD;&#x6570;&#x7B49;. </li>
<li><strong>afl-llvm-pass.so.cc</strong>: LLVM &#x63D2;&#x6869; Pass &#x7684;&#x5B9E;&#x73B0;&#x6587;&#x4EF6;, &#x5B9A;&#x4E49;&#x5728; LLVM &#x7F16;&#x8BD1;&#x94FE;&#x4E2D;&#x63D2;&#x5165;&#x8986;&#x76D6;&#x7387;&#x4EE3;&#x7801;&#x7684;&#x903B;&#x8F91;, &#x4E3B;&#x8981;&#x8D1F;&#x8D23;&#x63D2;&#x5165;&#x8BA1;&#x6570;&#x70B9;, &#x8BB0;&#x5F55;&#x6267;&#x884C;&#x8DEF;&#x5F84;&#x4FE1;&#x606F;. </li>
<li><strong>afl-compiler-rt.o.c (afl-llvm-rt.o.c in old afl)</strong>: AFL++ &#x7684;&#x8FD0;&#x884C;&#x65F6;&#x5E93;&#x6587;&#x4EF6;, &#x63D0;&#x4F9B;&#x8BA1;&#x6570;&#x5668;&#x66F4;&#x65B0;&#x3001;&#x5171;&#x4EAB;&#x5185;&#x5B58;&#x64CD;&#x4F5C;&#x7B49;&#x63D2;&#x6869;&#x65F6;&#x6240;&#x9700;&#x7684;&#x5E95;&#x5C42;&#x529F;&#x80FD;</li>
</ul>
<h2 id="afl-compiler-rtoc">afl-compiler-rt.o.c</h2>
<h3 id="&#x5168;&#x5C40;&#x53D8;&#x91CF;">&#x5168;&#x5C40;&#x53D8;&#x91CF;</h3>
<pre><code class="lang-c"><span class="hljs-comment">// buffer for share memory data &amp; execution counter </span>
<span class="hljs-keyword">static</span> u8  __afl_area_initial[MAP_INITIAL_SIZE];

<span class="hljs-comment">// __afl_area_ptr* points to memory where instrumentation code writing the data</span>
<span class="hljs-keyword">static</span> u8 *__afl_area_ptr_dummy = __afl_area_initial;
<span class="hljs-keyword">static</span> u8 *__afl_area_ptr_backup = __afl_area_initial;
u8        *__afl_area_ptr = __afl_area_initial;

<span class="hljs-comment">// point to mutation dictionary</span>
u8        *__afl_dictionary;
u32 __afl_dictionary_len;

<span class="hljs-comment">// points to testcase buffer </span>
u8        *__afl_fuzz_ptr;
<span class="hljs-comment">// the length of testcase input buffer</span>
<span class="hljs-keyword">static</span> u32 __afl_fuzz_len_dummy;
u32       *__afl_fuzz_len = &amp;__afl_fuzz_len_dummy;

<span class="hljs-comment">// flag shows whether enables sharedmem fuzzing</span>
<span class="hljs-keyword">int</span>        __afl_sharedmem_fuzzing __attribute__((weak));

<span class="hljs-comment">// the last location of instrumentation</span>
u32 __afl_final_loc;
<span class="hljs-comment">// the first location of valid instrumentation</span>
u32 __afl_first_final_loc;

<span class="hljs-comment">// share memory size default 2^16 == 64 KB == 65536</span>
u32 __afl_map_size = MAP_SIZE;
<span class="hljs-comment">// points to mappings of share memory coverage</span>
u64 __afl_map_addr;

<span class="hljs-comment">// compatible with old version of forkserver (ignored)</span>
u32 __afl_old_forkserver;

<span class="hljs-comment">//...</span>

<span class="hljs-comment">/* 1 if we are running in afl, and the forkserver was started, else 0 */</span>
u32 __afl_connected = <span class="hljs-number">0</span>;

<span class="hljs-comment">// for the __AFL_COVERAGE_ON/__AFL_COVERAGE_OFF features to work:</span>
<span class="hljs-keyword">int</span>        __afl_selective_coverage __attribute__((weak)); <span class="hljs-comment">// whether enables selective coverage</span>
<span class="hljs-keyword">int</span>        __afl_selective_coverage_start_off __attribute__((weak)); <span class="hljs-comment">// disables selective coverage from beginning</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __afl_selective_coverage_temp = <span class="hljs-number">1</span>; <span class="hljs-comment">// temp state of selective coverage</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)</span>
PREV_LOC_T __afl_prev_loc[NGRAM_SIZE_MAX];
PREV_LOC_T __afl_prev_caller[CTX_MAX_K];
u32        __afl_prev_ctx;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
__thread PREV_LOC_T __afl_prev_loc[NGRAM_SIZE_MAX]; <span class="hljs-comment">// context aware coverage</span>
__thread PREV_LOC_T __afl_prev_caller[CTX_MAX_K]; <span class="hljs-comment">// call stack aware coverage </span>
__thread u32        __afl_prev_ctx; <span class="hljs-comment">// ID of context</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-comment">// mapping for following current comparing instruction</span>
<span class="hljs-keyword">struct</span> cmp_map *__afl_cmp_map;
<span class="hljs-keyword">struct</span> cmp_map *__afl_cmp_map_backup;
<span class="hljs-comment">// log length of comparing instructions</span>
<span class="hljs-keyword">static</span> u8 __afl_cmplog_max_len = <span class="hljs-number">32</span>;  <span class="hljs-comment">// 16-32</span>

<span class="hljs-comment">// child process ID for forkserver mode</span>
<span class="hljs-keyword">static</span> s32 child_pid;
<span class="hljs-comment">// pointer for recovering signal</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">void</span> <span class="hljs-params">(*old_sigterm_handler)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> </span>= <span class="hljs-number">0</span>;

<span class="hljs-comment">/* Running in persistent mode? */</span>
<span class="hljs-keyword">static</span> u8 is_persistent;

<span class="hljs-comment">/* Are we in sancov mode? */</span>
<span class="hljs-keyword">static</span> u8 _is_sancov;

<span class="hljs-comment">/* Debug? */</span>
<span class="hljs-comment">/*static*/</span> u32 __afl_debug;

<span class="hljs-comment">/* Already initialized markers to avoid re-initialization */</span>
u32 __afl_already_initialized_shm;
u32 __afl_already_initialized_forkserver;
u32 __afl_already_initialized_first;
u32 __afl_already_initialized_second;
u32 __afl_already_initialized_early;
u32 __afl_already_initialized_init;

<span class="hljs-comment">/* Dummy pipe for area_is_valid() */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __afl_dummy_fd[<span class="hljs-number">2</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">2</span>};
</code></pre>
<h3 id="&#x7ED3;&#x6784;&#x4F53;">&#x7ED3;&#x6784;&#x4F53;</h3>
<pre><code class="lang-c"><span class="hljs-comment">// information for PCGuard coverage</span>
<span class="hljs-keyword">struct</span> <span class="hljs-keyword">afl_module_info_t</span> {

  <span class="hljs-comment">// A unique id starting with 0</span>
  u32 id;

  <span class="hljs-comment">// Name and base address of the module</span>
  <span class="hljs-keyword">char</span>     *name;
  <span class="hljs-keyword">uintptr_t</span> base_address;

  <span class="hljs-comment">// PC Guard start/stop</span>
  u32 *start;
  u32 *stop;

  <span class="hljs-comment">// PC Table begin/end</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_beg;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_end;

  u8 mapped; <span class="hljs-comment">// whether mapped or not</span>

  <span class="hljs-keyword">afl_module_info_t</span> *next; <span class="hljs-comment">// next pointer: link data structure organizes multi modules</span>

};

<span class="hljs-comment">// assists for coverage</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {

  <span class="hljs-keyword">uintptr_t</span> PC, PCFlags;

} PCTableEntry;

<span class="hljs-comment">// header pointer points to module coverage link</span>
<span class="hljs-keyword">afl_module_info_t</span> *__afl_module_info = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// pc mapping table size</span>
u32        __afl_pcmap_size = <span class="hljs-number">0</span>;
<span class="hljs-comment">// points to program counter array</span>
<span class="hljs-keyword">uintptr_t</span> *__afl_pcmap_ptr = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// filtering the area where we want to skip instrumentation</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {

  <span class="hljs-keyword">uintptr_t</span> start; <span class="hljs-comment">// start of skip area</span>
  u32       len; <span class="hljs-comment">// length of skip area</span>

} FilterPCEntry;
u32            __afl_filter_pcs_size = <span class="hljs-number">0</span>; <span class="hljs-comment">// number of areas</span>
FilterPCEntry *__afl_filter_pcs = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// filtering arrays pointer</span>
u8            *__afl_filter_pcs_module = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// filtering module pointer</span>
</code></pre>
<h3 id="share-memory">Share Memory</h3>
<pre><code class="lang-c"><span class="hljs-comment">/* SHM fuzzing setup for store testcase input */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __afl_map_shm_fuzz() {
  <span class="hljs-comment">// get the id of share memory of input </span>
  <span class="hljs-keyword">char</span> *id_str = getenv(SHM_FUZZ_ENV_VAR);
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (id_str) {

    u8 *<span class="hljs-built_in">map</span> = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// selet share memory mode by USEMMAP</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>         shm_fd = <span class="hljs-number">-1</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shm_open() failed for fuzz\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-built_in">map</span> =
        (u8 *)mmap(<span class="hljs-number">0</span>, MAX_FILE + <span class="hljs-keyword">sizeof</span>(u32), PROT_READ, MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);
    <span class="hljs-built_in">map</span> = (u8 *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-comment">// ...</span>

    __afl_fuzz_len = (u32 *)<span class="hljs-built_in">map</span>;
    __afl_fuzz_ptr = <span class="hljs-built_in">map</span> + <span class="hljs-keyword">sizeof</span>(u32);

    <span class="hljs-comment">// ...</span>

  } <span class="hljs-keyword">else</span> {

    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: variable for fuzzing shared memory is not set\n&quot;</span>);
    send_forkserver_error(FS_ERROR_SHM_OPEN);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

  }

}


<span class="hljs-comment">/* SHM setup. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __afl_map_shm(<span class="hljs-keyword">void</span>) {

  <span class="hljs-keyword">if</span> (__afl_already_initialized_shm) <span class="hljs-keyword">return</span>;
  __afl_already_initialized_shm = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// if we are not running in afl ensure the map exists</span>
  <span class="hljs-keyword">if</span> (!__afl_area_ptr) { __afl_area_ptr = __afl_area_ptr_dummy; }

  <span class="hljs-keyword">char</span> *id_str = getenv(SHM_ENV_VAR);

  <span class="hljs-keyword">if</span> (__afl_final_loc) {

    <span class="hljs-comment">// adjust map_size by final_loc</span>
    __afl_map_size = __afl_final_loc + <span class="hljs-number">1</span>;  <span class="hljs-comment">// as we count starting 0</span>

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// remind to set larger MAP_SIZE</span>
    <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_SIZE) {

      <span class="hljs-keyword">char</span> *ptr;
      u32   val = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> ((ptr = getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>)) != <span class="hljs-literal">NULL</span>) { val = atoi(ptr); }
      <span class="hljs-keyword">if</span> (val &lt; __afl_final_loc) {

        <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_INITIAL_SIZE &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) {

          <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,
                  <span class="hljs-string">&quot;Warning: AFL++ tools might need to set AFL_MAP_SIZE to %u &quot;</span>
                  <span class="hljs-string">&quot;to be able to run this instrumented program if this &quot;</span>
                  <span class="hljs-string">&quot;crashes!\n&quot;</span>,
                  __afl_final_loc);

        }

      }

    }

  }

  <span class="hljs-comment">// check if disable sharedmem fuzzing</span>
  <span class="hljs-keyword">if</span> (__afl_sharedmem_fuzzing &amp;&amp; (!id_str || !getenv(SHM_FUZZ_ENV_VAR) ||
                                  fcntl(FORKSRV_FD, F_GETFD) == <span class="hljs-number">-1</span> ||
                                  fcntl(FORKSRV_FD + <span class="hljs-number">1</span>, F_GETFD) == <span class="hljs-number">-1</span>)) {

    <span class="hljs-comment">// ...</span>
    __afl_sharedmem_fuzzing = <span class="hljs-number">0</span>;

  }

  <span class="hljs-comment">// init map pointers </span>
  <span class="hljs-keyword">if</span> (!id_str) {

    u32 val = <span class="hljs-number">0</span>;
    u8 *ptr;

    <span class="hljs-keyword">if</span> ((ptr = getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>)) != <span class="hljs-literal">NULL</span>) { val = atoi(ptr); }

    <span class="hljs-keyword">if</span> (val &gt; MAP_INITIAL_SIZE &amp;&amp; val &gt; __afl_final_loc) {

      __afl_map_size = val;

    } <span class="hljs-keyword">else</span> {

      <span class="hljs-keyword">if</span> (__afl_first_final_loc &gt; MAP_INITIAL_SIZE) {

        <span class="hljs-comment">// done in second stage constructor</span>
        __afl_map_size = __afl_first_final_loc;

      } <span class="hljs-keyword">else</span> {

        __afl_map_size = MAP_INITIAL_SIZE;

      }

    }

    <span class="hljs-keyword">if</span> (__afl_map_size &gt; MAP_INITIAL_SIZE &amp;&amp; __afl_final_loc &lt; __afl_map_size) {

      __afl_final_loc = __afl_map_size;

    }

    <span class="hljs-comment">// ...</span>

  }

  <span class="hljs-comment">/* If we&apos;re running under AFL, attach to the appropriate region, replacing the
     early-stage __afl_area_initial region that is needed to allow some really
     hacky .init code to work correctly in projects such as OpenSSL. */</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// share memory mapping to fuzzer mmap</span>
  <span class="hljs-keyword">if</span> (id_str) {

    <span class="hljs-keyword">if</span> (__afl_area_ptr &amp;&amp; __afl_area_ptr != __afl_area_initial &amp;&amp;
        __afl_area_ptr != __afl_area_ptr_dummy) {

      <span class="hljs-keyword">if</span> (__afl_map_addr) {

        munmap((<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_final_loc);

      } <span class="hljs-keyword">else</span> {

        <span class="hljs-built_in">free</span>(__afl_area_ptr);

      }

      __afl_area_ptr = __afl_area_ptr_dummy;

    }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>    *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>            shm_fd = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *shm_base = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shm_open() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-comment">/* map the shared memory segment to the address space of the process */</span>
    <span class="hljs-keyword">if</span> (__afl_map_addr) {

      shm_base =
          mmap((<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_map_size, PROT_READ | PROT_WRITE,
               MAP_FIXED_NOREPLACE | MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);

    } <span class="hljs-keyword">else</span> {

      shm_base = mmap(<span class="hljs-number">0</span>, __afl_map_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                      shm_fd, <span class="hljs-number">0</span>);

    }

    close(shm_fd);
    shm_fd = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (shm_base == MAP_FAILED) {
      <span class="hljs-comment">// ...</span>
    }

    __afl_area_ptr = shm_base;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);

    <span class="hljs-keyword">if</span> (__afl_map_size &amp;&amp; __afl_map_size &gt; MAP_SIZE) {

      u8 *map_env = (u8 *)getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>);
      <span class="hljs-keyword">if</span> (!map_env || atoi((<span class="hljs-keyword">char</span> *)map_env) &lt; MAP_SIZE) {

        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;FS_ERROR_MAP_SIZE\n&quot;</span>);
        send_forkserver_error(FS_ERROR_MAP_SIZE);
        _exit(<span class="hljs-number">1</span>);

      }

    }

    __afl_area_ptr = (u8 *)shmat(shm_id, (<span class="hljs-keyword">void</span> *)__afl_map_addr, <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* Whooooops. */</span>
    <span class="hljs-comment">// ...</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    <span class="hljs-comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,
       our parent doesn&apos;t give up on us. */</span>
    <span class="hljs-comment">// write 1 into __afl_area_ptr[0] (shm[0]) to avoid being regarded as no coverage</span>
    __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((!__afl_area_ptr || __afl_area_ptr == __afl_area_initial) &amp;&amp;

             __afl_map_addr) {

    __afl_area_ptr = (u8 *)mmap(
        (<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_map_size, PROT_READ | PROT_WRITE,
        MAP_FIXED_NOREPLACE | MAP_SHARED | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (__afl_area_ptr == MAP_FAILED) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;can not acquire mmap for address %p\n&quot;</span>,
              (<span class="hljs-keyword">void</span> *)__afl_map_addr);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }
    <span class="hljs-comment">// if instrumentation needs more space to store then malloc larger area</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_INITIAL_SIZE &amp;&amp;

             __afl_final_loc &gt; __afl_first_final_loc) {

    <span class="hljs-keyword">if</span> (__afl_area_initial != __afl_area_ptr_dummy) {

      <span class="hljs-built_in">free</span>(__afl_area_ptr_dummy);

    }

    __afl_map_size = __afl_final_loc + <span class="hljs-number">1</span>;
    __afl_area_ptr_dummy = (u8 *)<span class="hljs-built_in">malloc</span>(__afl_map_size);
    __afl_area_ptr = __afl_area_ptr_dummy;

    <span class="hljs-keyword">if</span> (!__afl_area_ptr_dummy) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,
              <span class="hljs-string">&quot;Error: AFL++ could not acquire %u bytes of memory, exiting!\n&quot;</span>,
              __afl_final_loc);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    }

  }  <span class="hljs-comment">// else: nothing to be done</span>

  __afl_area_ptr_backup = __afl_area_ptr;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">if</span> (__afl_selective_coverage) {

    <span class="hljs-keyword">if</span> (__afl_map_size &gt; MAP_INITIAL_SIZE) {

      __afl_area_ptr_dummy = (u8 *)<span class="hljs-built_in">malloc</span>(__afl_map_size);

    }

    <span class="hljs-keyword">if</span> (__afl_area_ptr_dummy) {

      <span class="hljs-keyword">if</span> (__afl_selective_coverage_start_off) {

        __afl_area_ptr = __afl_area_ptr_dummy;

      }

    } <span class="hljs-keyword">else</span> {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: __afl_selective_coverage failed!\n&quot;</span>);
      __afl_selective_coverage = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// continue;</span>

    }

  }

  <span class="hljs-comment">// share memory of comparing instruction log</span>
  id_str = getenv(CMPLOG_SHM_ENV_VAR);
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">if</span> (id_str) {

    <span class="hljs-comment">// /dev/null doesn&apos;t work so we use /dev/urandom</span>
    <span class="hljs-keyword">if</span> ((__afl_dummy_fd[<span class="hljs-number">1</span>] = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, O_WRONLY)) &lt; <span class="hljs-number">0</span>) {

      <span class="hljs-keyword">if</span> (pipe(__afl_dummy_fd) &lt; <span class="hljs-number">0</span>) { __afl_dummy_fd[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; }

    }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>     *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>             shm_fd = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">struct</span> cmp_map *shm_base = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      perror(<span class="hljs-string">&quot;shm_open() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-comment">/* map the shared memory segment to the address space of the process */</span>
    shm_base = mmap(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cmp_map), PROT_READ | PROT_WRITE,
                    MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (shm_base == MAP_FAILED) {

      close(shm_fd);
      shm_fd = <span class="hljs-number">-1</span>;

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;mmap() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);

    }

    __afl_cmp_map = shm_base;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);

    __afl_cmp_map = (<span class="hljs-keyword">struct</span> cmp_map *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    __afl_cmp_map_backup = __afl_cmp_map;

    <span class="hljs-keyword">if</span> (!__afl_cmp_map || __afl_cmp_map == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>) {

      perror(<span class="hljs-string">&quot;shmat for cmplog&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      _exit(<span class="hljs-number">1</span>);

    }

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __AFL_CODE_COVERAGE</span>
  <span class="hljs-comment">// share memory of PCMAP (e.g. from PC to source code)</span>
  <span class="hljs-keyword">char</span> *pcmap_id_str = getenv(<span class="hljs-string">&quot;__AFL_PCMAP_SHM_ID&quot;</span>);

  <span class="hljs-keyword">if</span> (pcmap_id_str) {

    __afl_pcmap_size = __afl_map_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *);
    u32 shm_id = atoi(pcmap_id_str);

    __afl_pcmap_ptr = (<span class="hljs-keyword">uintptr_t</span> *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (__afl_debug) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;DEBUG: Received %p via shmat for pcmap\n&quot;</span>,
              __afl_pcmap_ptr);

    }

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// __AFL_CODE_COVERAGE</span></span>

  <span class="hljs-keyword">if</span> (!__afl_cmp_map &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_CMPLOG_DEBUG&quot;</span>)) {

    __afl_cmp_map_backup = __afl_cmp_map = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cmp_map));

  }

  <span class="hljs-comment">// adjust CMPLOG length</span>
  <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;AFL_CMPLOG_MAX_LEN&quot;</span>)) {

    <span class="hljs-keyword">int</span> tmp = atoi(getenv(<span class="hljs-string">&quot;AFL_CMPLOG_MAX_LEN&quot;</span>));
    <span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">16</span> &amp;&amp; tmp &lt;= <span class="hljs-number">32</span>) { __afl_cmplog_max_len = tmp; }

  }

}
</code></pre>
<h2 id="afl-llvm-passsocc">afl-llvm-pass.so.cc</h2>
<h3 id="aflcoverage">AFLCoverage</h3>
<pre><code class="lang-c"><span class="hljs-keyword">namespace</span> {

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
<span class="hljs-keyword">class</span> AFLCoverage : <span class="hljs-keyword">public</span> PassInfoMixin&lt;AFLCoverage&gt; { <span class="hljs-comment">// &lt;!&gt; core pass class for instrumentation</span>

 <span class="hljs-keyword">public</span>:
  AFLCoverage() {

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">class</span> AFLCoverage : <span class="hljs-keyword">public</span> ModulePass {

 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> ID;
  AFLCoverage() : ModulePass(ID) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    initInstrumentList(); <span class="hljs-comment">// init instrumentation allow/skip list</span>

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
  <span class="hljs-function">PreservedAnalyses <span class="hljs-title">run</span><span class="hljs-params">(Module &amp;M, ModuleAnalysisManager &amp;MAM)</span></span>; <span class="hljs-comment">// entry function</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> override</span>; <span class="hljs-comment">// old entry function</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

 <span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">uint32_t</span>    ngram_size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ngram related</span>
  <span class="hljs-keyword">uint32_t</span>    ctx_k = <span class="hljs-number">0</span>; <span class="hljs-comment">// context related </span>
  <span class="hljs-keyword">uint32_t</span>    map_size = MAP_SIZE; <span class="hljs-comment">// map_size</span>
  <span class="hljs-keyword">uint32_t</span>    function_minimum_size = <span class="hljs-number">1</span>; <span class="hljs-comment">// function minimum size</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ctx_str = <span class="hljs-literal">NULL</span>, *caller_str = <span class="hljs-literal">NULL</span>, *skip_nozero = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// context related</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *use_threadsafe_counters = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// set threadsafe counters</span>

};

}  <span class="hljs-comment">// namespace</span>
</code></pre>
<h3 id="pass-register">Pass Register</h3>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">LLVM_ATTRIBUTE_WEAK PassPluginLibraryInfo <span class="hljs-title">llvmGetPassPluginInfo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// use PassPluginLibraryInfo to register pass</span>
  <span class="hljs-keyword">return</span> {LLVM_PLUGIN_API_VERSION, <span class="hljs-string">&quot;AFLCoverage&quot;</span>, <span class="hljs-string">&quot;v0.1&quot;</span>,
          <span class="hljs-comment">/* lambda to insert our pass into the pass pipeline. */</span>
          [](PassBuilder &amp;PB) {

  #<span class="hljs-keyword">if</span> <span class="hljs-number">1</span>
    #<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &lt;= <span class="hljs-number">13</span>
            <span class="hljs-keyword">using</span> OptimizationLevel = <span class="hljs-keyword">typename</span> PassBuilder::OptimizationLevel; <span class="hljs-comment">// set optimization level</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 16</span>
      <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 20</span>
            PB.registerPipelineStartEPCallback( <span class="hljs-comment">// version 20+ register</span>
      #<span class="hljs-keyword">else</span>
            PB.registerOptimizerEarlyEPCallback( <span class="hljs-comment">// version 16-19 register</span>
      #endif
    #<span class="hljs-keyword">else</span>
            PB.registerOptimizerLastEPCallback( <span class="hljs-comment">// version 15- register</span>
    #endif
                [](ModulePassManager &amp;MPM, OptimizationLevel OL) {

                  MPM.addPass(AFLCoverage()); <span class="hljs-comment">// export pass AFLCoverage</span>

                });

  <span class="hljs-comment">/* TODO LTO registration */</span>
  #<span class="hljs-keyword">else</span>
    <span class="hljs-comment">// ...</span>

  #endif

          }}; <span class="hljs-comment">// return \{\{*}};</span>

} <span class="hljs-comment">// llvmGetPassPluginInfo</span>

#<span class="hljs-keyword">else</span>

<span class="hljs-keyword">char</span> AFLCoverage::ID = <span class="hljs-number">0</span>;
#endif
</code></pre>
<h3 id="instrumentation-main-function">Instrumentation &quot;Main Function&quot;</h3>
<p><code>AFLCoverage::run()</code> or <code>AFLCoverage::runOnModule</code> &#x662F;&#x63D2;&#x6869; pass &#x7684;&#x5165;&#x53E3;&#x51FD;&#x6570;&#x7528;&#x4E8E;&#x904D;&#x5386; <code>Module &amp;M</code> &#x5E76;&#x63D2;&#x5165;&#x68C0;&#x67E5;&#x70B9;. &#x5176;&#x4F59;&#x903B;&#x8F91;&#x89C1;&#x4E0B;&#x9762;&#x4EE3;&#x7801;&#x4E2D;&#x7684;&#x6CE8;&#x91CA;</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
PreservedAnalyses AFLCoverage::run(Module &amp;M, ModuleAnalysisManager &amp;MAM) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">bool</span> AFLCoverage::runOnModule(Module &amp;M) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  LLVMContext &amp;C = M.getContext(); <span class="hljs-comment">// get the context of M</span>

  IntegerType *Int8Ty = IntegerType::getInt8Ty(C); <span class="hljs-comment">// define i8 type</span>
  IntegerType *Int32Ty = IntegerType::getInt32Ty(C); <span class="hljs-comment">// define i32 type</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS <span class="hljs-comment">// &quot;vectorize instrumentation&quot; flag</span></span>
  IntegerType *IntLocTy = <span class="hljs-comment">// if AFL_HAVE_VECTOR_INTRINSICS enables, define IntLocTy type to store prev_loc</span>
      IntegerType::getIntNTy(C, <span class="hljs-keyword">sizeof</span>(PREV_LOC_T) * CHAR_BIT);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">struct</span> timeval  tv; <span class="hljs-comment">// time value for now</span>
  <span class="hljs-keyword">struct</span> timezone tz; <span class="hljs-comment">// time zone for now</span>
  u32             rand_seed;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    cur_loc = <span class="hljs-number">0</span>; <span class="hljs-comment">// current instrumented location ID</span>

  <span class="hljs-comment">/* Setup random() so we get Actually Random(TM) outputs from AFL_R() */</span>
  gettimeofday(&amp;tv, &amp;tz); <span class="hljs-comment">// get current time of the day</span>
  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid(); <span class="hljs-comment">// xor with process pid to get rand seed</span>
  AFL_SR(rand_seed); <span class="hljs-comment">// marcro to set rand seed (later uses AFL_R() to generate random number)</span>

  <span class="hljs-comment">/* Show a banner */</span>

  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>); <span class="hljs-comment">// set no buffer of IO</span>

  <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;AFL_DEBUG&quot;</span>)) debug = <span class="hljs-number">1</span>; <span class="hljs-comment">// if AFL_DEBUG enables then set debug = 1</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
  <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;AFL_SAN_NO_INST&quot;</span>)) { <span class="hljs-comment">// if AFL_SAN_NO_INST enables, then skip instrumentation</span>

    <span class="hljs-keyword">if</span> (debug) { <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Instrument disabled\n&quot;</span>); }
    <span class="hljs-keyword">return</span> PreservedAnalyses::all();

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;AFL_SAN_NO_INST&quot;</span>)) { <span class="hljs-comment">// if AFL_SAN_NO_INST enables, then skip instrumentation</span>

    <span class="hljs-keyword">if</span> (debug) { <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Instrument disabled\n&quot;</span>); }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

...
...
...

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
  <span class="hljs-keyword">return</span> PreservedAnalyses(); <span class="hljs-comment">// LLVM-11+ uses PreservedAnalyses to show IR modified</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// LLVM-10- uses true to show IR modified</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

}
</code></pre>
<p>&#x4E0B;&#x9762;&#x9010;&#x90E8;&#x5206;&#x89E3;&#x91CA;&#x4EE3;&#x7801;</p>
<p>&#x4E3B;&#x903B;&#x8F91;&#x8FDB;&#x6765;&#x8BBE;&#x7F6E;&#x53C2;&#x6570;&#x4EE5;&#x540E;, &#x5F00;&#x59CB;&#x8BBE;&#x7F6E;&#x63D2;&#x6869;&#x7387; <code>inst_ratio</code>, <code>neverzero counters</code>, <code>threadsafe counters</code>. &#x63A5;&#x7740;, &#x8BBE;&#x7F6E;&#x4E0A;&#x4E0B;&#x6587;&#x63D2;&#x6869;&#x76F8;&#x5173;&#x7684;&#x53D8;&#x91CF;, &#x5305;&#x62EC; <code>N-gram</code>, <code>ctx</code>, <code>caller</code>. </p>
<pre><code class="lang-c">  // if fd==2(stderr) &amp;&amp; AFL_QUIET disables &amp;&amp; AFL_DEBUG enables then output the version information 
  if ((isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) || getenv(&quot;AFL_DEBUG&quot;) != NULL) {

    SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST
              &quot; by &lt;lszekeres@google.com&gt; and &lt;adrian.herrera@anu.edu.au&gt;\n&quot;);

  } else // else set the flag be_quiet = 1

    be_quiet = 1;

  // ...

  /* Decide instrumentation ratio */

  char        *inst_ratio_str = getenv(&quot;AFL_INST_RATIO&quot;); // use AFL_INST_RATIO to set instrumentation ratio
  unsigned int inst_ratio = 100; // 100% as max

  if (inst_ratio_str) {
    // if inst_ratio_str is not numeric || inst_ratio == 0 || inst_ratio &gt; 100 then report error and exit
    if (sscanf(inst_ratio_str, &quot;%u&quot;, &amp;inst_ratio) != 1 || !inst_ratio ||
        inst_ratio &gt; 100)
      FATAL(&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;);

  }

#if LLVM_VERSION_MAJOR &lt; 9
  char *neverZero_counters_str = getenv(&quot;AFL_LLVM_NOT_ZERO&quot;); // LLVM-8- set AFL_LLVM_NOT_ZERO to disable neverZero counters
#endif
  skip_nozero = getenv(&quot;AFL_LLVM_SKIP_NEVERZERO&quot;); // LLVM-9+ set AFL_LLVM_SKIP_NEVERZERO to disable neverZero counters
  use_threadsafe_counters = getenv(&quot;AFL_LLVM_THREADSAFE_INST&quot;); // set AFL_LLVM_THREADSAFE_INST to enable threadsafe counters

  if ((isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) || !!getenv(&quot;AFL_DEBUG&quot;)) {

    if (use_threadsafe_counters) { // when enables threadsafe counters then skip neverzero counters

      skip_nozero = &quot;1&quot;;
      SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST &quot; using thread safe counters\n&quot;);

    } else {

      SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST
                &quot; using non-thread safe instrumentation\n&quot;);

    }

  }

  unsigned PrevLocSize = 0;
  unsigned PrevCallerSize = 0;

  char *ngram_size_str = getenv(&quot;AFL_LLVM_NGRAM_SIZE&quot;); // set ngram_size by AFL_LLVM_NGRAM_SIZE 
  if (!ngram_size_str) ngram_size_str = getenv(&quot;AFL_NGRAM_SIZE&quot;); // or set ngram_size by AFL_NGRAM_SIZE
  char *ctx_k_str = getenv(&quot;AFL_LLVM_CTX_K&quot;); // enables context-aware instrumentaion size by setting AFL_LLVM_CTX_K
  if (!ctx_k_str) ctx_k_str = getenv(&quot;AFL_CTX_K&quot;); // or enables context-aware instrumentaion size by setting AFL_CTX_K
  ctx_str = getenv(&quot;AFL_LLVM_CTX&quot;); // enables instrument_ctx by setting AFL_LLVM_CTX
  caller_str = getenv(&quot;AFL_LLVM_CALLER&quot;); // or enables instrument_ctx by setting AFL_LLVM_CALLER

  bool instrument_ctx = ctx_str || caller_str; // set instrument_ctx to enable context-aware instrumentation
</code></pre>
<p>&#x5F80;&#x4E0B;&#x662F;&#x8BBE;&#x7F6E;&#x5411;&#x91CF;&#x5316;&#x63D2;&#x6869;&#x7684;&#x53C2;&#x6570;, &#x5305;&#x62EC; <code>n-gram</code>, <code>k-context</code>. </p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS <span class="hljs-comment">// AFL_HAVE_VECTOR_INTRINSICS to enable vectorize instrumentation, e.g. N-gram path log</span></span>
  <span class="hljs-comment">/* Decide previous location vector size (must be a power of two) */</span>
  VectorType *PrevLocTy = <span class="hljs-literal">NULL</span>;

  <span class="hljs-keyword">if</span> (ngram_size_str)
    <span class="hljs-comment">// if ngram_size is not numeric || ngram_size &lt;= 1 || ngram_size &gt; allowed NGRAM_SIZE_MAX then report error and exit</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(ngram_size_str, <span class="hljs-string">&quot;%u&quot;</span>, &amp;ngram_size) != <span class="hljs-number">1</span> || ngram_size &lt; <span class="hljs-number">2</span> ||
        ngram_size &gt; NGRAM_SIZE_MAX)
      FATAL(
          <span class="hljs-string">&quot;Bad value of AFL_NGRAM_SIZE (must be between 2 and NGRAM_SIZE_MAX &quot;</span>
          <span class="hljs-string">&quot;(%u))&quot;</span>,
          NGRAM_SIZE_MAX);
  <span class="hljs-comment">// ngram_size == 1 makes no sense to record only 1 path, so set to 0</span>
  <span class="hljs-keyword">if</span> (ngram_size == <span class="hljs-number">1</span>) ngram_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (ngram_size)
    PrevLocSize = ngram_size - <span class="hljs-number">1</span>; <span class="hljs-comment">// PrevLoc to store ngram_size - 1 path log</span>
  <span class="hljs-keyword">else</span>
    PrevLocSize = <span class="hljs-number">1</span>; <span class="hljs-comment">// default is 1</span>

  <span class="hljs-comment">/* Decide K-ctx vector size (must be a power of two) */</span>
  VectorType *PrevCallerTy = <span class="hljs-literal">NULL</span>;

  <span class="hljs-keyword">if</span> (ctx_k_str)
    <span class="hljs-comment">// check valid ctx_k_str setting</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(ctx_k_str, <span class="hljs-string">&quot;%u&quot;</span>, &amp;ctx_k) != <span class="hljs-number">1</span> || ctx_k &lt; <span class="hljs-number">1</span> || ctx_k &gt; CTX_MAX_K)
      FATAL(<span class="hljs-string">&quot;Bad value of AFL_CTX_K (must be between 1 and CTX_MAX_K (%u))&quot;</span>,
            CTX_MAX_K);

  <span class="hljs-keyword">if</span> (ctx_k == <span class="hljs-number">1</span>) { <span class="hljs-comment">// when ctx_k == 1 then only enables CALLER mode</span>

    ctx_k = <span class="hljs-number">0</span>;
    instrument_ctx = <span class="hljs-literal">true</span>;
    caller_str = ctx_k_str;  <span class="hljs-comment">// Enable CALLER instead</span>

  }

  <span class="hljs-keyword">if</span> (ctx_k) { <span class="hljs-comment">// when ctx_k &gt;= 2 then enables context instrumentation</span>

    PrevCallerSize = ctx_k; <span class="hljs-comment">// set the PrevCallerSize as k</span>
    instrument_ctx = <span class="hljs-literal">true</span>;

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">// disables context instrumentation</span></span>
  <span class="hljs-keyword">if</span> (ngram_size_str) <span class="hljs-comment">// report error when setting ngram_size but not setting AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LLVM_VERSION_PATCH</span>
    FATAL(
        <span class="hljs-string">&quot;Sorry, NGRAM branch coverage is not supported with llvm version &quot;</span>
        <span class="hljs-string">&quot;%d.%d.%d!&quot;</span>,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, <span class="hljs-number">0</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    FATAL(
        <span class="hljs-string">&quot;Sorry, NGRAM branch coverage is not supported with llvm version &quot;</span>
        <span class="hljs-string">&quot;%d.%d.%d!&quot;</span>,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, LLVM_VERSION_PATCH);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span> (ctx_k_str) <span class="hljs-comment">// report error when setting ctx_k but not setting AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LLVM_VERSION_PATCH</span>
    FATAL(
        <span class="hljs-string">&quot;Sorry, K-CTX branch coverage is not supported with llvm version &quot;</span>
        <span class="hljs-string">&quot;%d.%d.%d!&quot;</span>,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, <span class="hljs-number">0</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    FATAL(
        <span class="hljs-string">&quot;Sorry, K-CTX branch coverage is not supported with llvm version &quot;</span>
        <span class="hljs-string">&quot;%d.%d.%d!&quot;</span>,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, LLVM_VERSION_PATCH);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  PrevLocSize = <span class="hljs-number">1</span>; <span class="hljs-comment">// default PrevLocSize is 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-keyword">int</span> PrevLocVecSize = PowerOf2Ceil(PrevLocSize); <span class="hljs-comment">// PrevLocSize &lt;= 2^n (where n is the smallest to make inequality hold)</span>
  <span class="hljs-keyword">if</span> (ngram_size)
    PrevLocTy = VectorType::get(IntLocTy, PrevLocVecSize 
                                <span class="hljs-comment">// create vector PrevLocTy[PrevLocVecSize] whose element type is IntLocTy</span>
  #<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">12</span> <span class="hljs-comment">// LLVM-12+ supports scalable vector</span>
                                ,
                                <span class="hljs-literal">false</span> <span class="hljs-comment">// not scalable to expend vector</span>
  #endif
    );
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-keyword">int</span> PrevCallerVecSize = PowerOf2Ceil(PrevCallerSize); 
  <span class="hljs-comment">// PrevCallerSize &lt;= 2^n (where n is the smallest to make inequality hold)</span>
  <span class="hljs-keyword">if</span> (ctx_k)
    PrevCallerTy = VectorType::get(IntLocTy, PrevCallerVecSize
                                   <span class="hljs-comment">// create vector PrevCallerTy[PrevCallerVecSize] whose element type is IntLocTy</span>
  #<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">12</span> <span class="hljs-comment">// LLVM-12+ supports scalable vector</span>
                                   ,
                                   <span class="hljs-literal">false</span> <span class="hljs-comment">// not scalable to expend vector</span>
  #endif
    );
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>&#x8BBE;&#x7F6E;&#x5B8C;&#x4E0A;&#x4E0B;&#x6587;&#x76F8;&#x5173;&#x53C2;&#x6570;&#x540E;, &#x63A5;&#x7740;&#x662F;&#x8BBE;&#x7F6E;&#x5171;&#x4EAB;&#x5185;&#x5B58; <code>SHM</code> &#x7684;&#x76F8;&#x5173;&#x53D8;&#x91CF;</p>
<pre><code class="lang-c">  <span class="hljs-comment">/* Get globals for the SHM region and the previous location. Note that
     __afl_prev_loc is thread-local. */</span>
  <span class="hljs-comment">// set the global variable __afl_area_ptr, whose type is i8* (Int8Ty pointer).</span>
  GlobalVariable *AFLMapPtr = <span class="hljs-comment">// points to bitmap share memory</span>
      <span class="hljs-keyword">new</span> GlobalVariable(M, PointerType::get(Int8Ty, <span class="hljs-number">0</span>), <span class="hljs-literal">false</span>,
                         GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_area_ptr&quot;</span>);
  GlobalVariable *AFLPrevLoc; <span class="hljs-comment">// last basic block location</span>
  GlobalVariable *AFLPrevCaller; <span class="hljs-comment">// last caller location</span>
  GlobalVariable *AFLContext = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// last function ID (caller mode enabling), which is thread local storage (TLS)</span>

  <span class="hljs-keyword">if</span> (ctx_str || caller_str) <span class="hljs-comment">// if enables context instrumentation then create global variable __afl_prev_ctx</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS) <span class="hljs-comment">// ANDROID not supports TLS</span></span>
    AFLContext = <span class="hljs-keyword">new</span> GlobalVariable(
        M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_prev_ctx&quot;</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    AFLContext = <span class="hljs-keyword">new</span> GlobalVariable(
        M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_prev_ctx&quot;</span>, <span class="hljs-number">0</span>,
        GlobalVariable::GeneralDynamicTLSModel, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-keyword">if</span> (ngram_size) <span class="hljs-comment">// if enables ngram then create global variable __afl_prev_loc to store last basic block</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)</span>
    AFLPrevLoc = <span class="hljs-keyword">new</span> GlobalVariable(
        M, PrevLocTy, <span class="hljs-comment">/* isConstant */</span> <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage,
        <span class="hljs-comment">/* Initializer */</span> <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;__afl_prev_loc&quot;</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    AFLPrevLoc = <span class="hljs-keyword">new</span> GlobalVariable(
        M, PrevLocTy, <span class="hljs-comment">/* isConstant */</span> <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage,
        <span class="hljs-comment">/* Initializer */</span> <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;__afl_prev_loc&quot;</span>,
        <span class="hljs-comment">/* InsertBefore */</span> <span class="hljs-literal">nullptr</span>, GlobalVariable::GeneralDynamicTLSModel,
        <span class="hljs-comment">/* AddressSpace */</span> <span class="hljs-number">0</span>, <span class="hljs-comment">/* IsExternallyInitialized */</span> <span class="hljs-literal">false</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// disables vectorize mode so create not-vector global variable __afl_prev_loc</span>
#endif
#<span class="hljs-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevLoc = <span class="hljs-keyword">new</span> GlobalVariable(
        M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_prev_loc&quot;</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  AFLPrevLoc = <span class="hljs-keyword">new</span> GlobalVariable(
      M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_prev_loc&quot;</span>, <span class="hljs-number">0</span>,
      GlobalVariable::GeneralDynamicTLSModel, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-keyword">if</span> (ctx_k) <span class="hljs-comment">// if enables caller then create global variable __afl_prev_caller to store last caller</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)</span>
    AFLPrevCaller = <span class="hljs-keyword">new</span> GlobalVariable(
        M, PrevCallerTy, <span class="hljs-comment">/* isConstant */</span> <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage,
        <span class="hljs-comment">/* Initializer */</span> <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;__afl_prev_caller&quot;</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    AFLPrevCaller = <span class="hljs-keyword">new</span> GlobalVariable(
        M, PrevCallerTy, <span class="hljs-comment">/* isConstant */</span> <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage,
        <span class="hljs-comment">/* Initializer */</span> <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;__afl_prev_caller&quot;</span>,
        <span class="hljs-comment">/* InsertBefore */</span> <span class="hljs-literal">nullptr</span>, GlobalVariable::GeneralDynamicTLSModel,
        <span class="hljs-comment">/* AddressSpace */</span> <span class="hljs-number">0</span>, <span class="hljs-comment">/* IsExternallyInitialized */</span> <span class="hljs-literal">false</span>);
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// disables vectorize mode so create not-vector global variable __afl_prev_caller</span>
#endif
#<span class="hljs-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevCaller =
        <span class="hljs-keyword">new</span> GlobalVariable(M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>,
                           <span class="hljs-string">&quot;__afl_prev_caller&quot;</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  AFLPrevCaller = <span class="hljs-keyword">new</span> GlobalVariable(
      M, Int32Ty, <span class="hljs-literal">false</span>, GlobalValue::ExternalLinkage, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;__afl_prev_caller&quot;</span>,
      <span class="hljs-number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
  <span class="hljs-comment">/* Create the vector shuffle mask for updating the previous block history.
     Note that the first element of the vector will store cur_loc, so just set
     it to undef to allow the optimizer to do its thing. */</span>

  SmallVector&lt;Constant *, <span class="hljs-number">32</span>&gt; PrevLocShuffle = {UndefValue::get(Int32Ty)};

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> I = <span class="hljs-number">0</span>; I &lt; PrevLocSize - <span class="hljs-number">1</span>; ++I)
    PrevLocShuffle.push_back(ConstantInt::get(Int32Ty, I));
    <span class="hljs-comment">// PrevLocShuffle = [cur_loc(UnderValue), prev_loc[0], prev_loc[1], ...]</span>

  <span class="hljs-comment">// fill remains of vector elements with PrevLocSize</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> I = PrevLocSize; I &lt; PrevLocVecSize; ++I)
    PrevLocShuffle.push_back(ConstantInt::get(Int32Ty, PrevLocSize));

  <span class="hljs-comment">// The mask will right shift the vector of PrevLoc and insert cur_loc into first place of vector</span>
  Constant *PrevLocShuffleMask = ConstantVector::get(PrevLocShuffle);

  <span class="hljs-comment">// same logic for PrevCallerShuffleMask </span>
  Constant                   *PrevCallerShuffleMask = <span class="hljs-literal">NULL</span>;
  SmallVector&lt;Constant *, <span class="hljs-number">32</span>&gt; PrevCallerShuffle = {UndefValue::get(Int32Ty)};

  <span class="hljs-keyword">if</span> (ctx_k) {

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> I = <span class="hljs-number">0</span>; I &lt; PrevCallerSize - <span class="hljs-number">1</span>; ++I)
      PrevCallerShuffle.push_back(ConstantInt::get(Int32Ty, I));
      <span class="hljs-comment">// PrevCallerShuffle = [cur_caller(UnderValue), prev_caller[0], prev_caller[1], ...]</span>

    <span class="hljs-comment">// fill remains of vector elements with PrevCallerSize</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> I = PrevCallerSize; I &lt; PrevCallerVecSize; ++I)
      PrevCallerShuffle.push_back(ConstantInt::get(Int32Ty, PrevCallerSize));

    <span class="hljs-comment">// The mask will right shift the vector of PrevCaller and insert cur_caller into first place of vector</span>
    PrevCallerShuffleMask = ConstantVector::get(PrevCallerShuffle);

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-comment">// other constants we need</span>
  ConstantInt *One = ConstantInt::get(Int8Ty, <span class="hljs-number">1</span>);

  Value    *PrevCtx = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// CTX sensitive coverage</span>
  LoadInst *PrevCaller = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// K-CTX coverage</span>
</code></pre>
<p><strong>&#x63D2;&#x6869;&#x7684;&#x4E3B;&#x8981;&#x903B;&#x8F91;</strong></p>
<pre><code class="lang-c">  <span class="hljs-comment">/* Instrument all the things! */</span>
  <span class="hljs-comment">// ----------&gt; main logic of instrumentation starts here &lt;----------</span>
  <span class="hljs-keyword">int</span> inst_blocks = <span class="hljs-number">0</span>; <span class="hljs-comment">// count of successfully instrumented blocks</span>
  scanForDangerousFunctions(&amp;M); <span class="hljs-comment">// scan M contains dangerous functions like fork, exec</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;F : M) { <span class="hljs-comment">// traverse all functions in Module M</span>

    <span class="hljs-keyword">int</span> has_calls = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (debug)
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;FUNCTION: %s (%zu)\n&quot;</span>, F.getName().str().c_str(),
              F.size());

    <span class="hljs-keyword">if</span> (!isInInstrumentList(&amp;F, MNAME)) { <span class="hljs-keyword">continue</span>; } <span class="hljs-comment">// skip function doesn&apos;t need instrument</span>

    <span class="hljs-keyword">if</span> (F.size() &lt; function_minimum_size) { <span class="hljs-keyword">continue</span>; } <span class="hljs-comment">// skip function with little basic blocks </span>

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Value *&gt; todo;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;BB : F) { <span class="hljs-comment">// traverse all basic blocks in Function F</span>

      BasicBlock::iterator IP = BB.getFirstInsertionPt(); <span class="hljs-comment">// IP points to first insertion point in BB</span>
      IRBuilder&lt;&gt;          IRB(&amp;(*IP)); <span class="hljs-comment">// IRBuilder inserts IR instruction</span>

      <span class="hljs-comment">// Context sensitive coverage</span>
      <span class="hljs-comment">// if enables instrument_ctx &amp;&amp; current BB is the first BB of function F, then ...</span>
      <span class="hljs-keyword">if</span> (instrument_ctx &amp;&amp; &amp;BB == &amp;F.getEntryBlock()) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
        <span class="hljs-keyword">if</span> (ctx_k) {

          PrevCaller = IRB.CreateLoad( <span class="hljs-comment">// CreateLoad(Type, Value*): load type data from Value* address</span>
  #<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
              PrevCallerTy,
  #endif
              AFLPrevCaller);

          <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
          PrevCaller-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                                  MDNode::get(C, None));
          PrevCtx = <span class="hljs-comment">// CreateZExt(Value*, Type*): zero extend an integer to wider type integer, </span>
                      <span class="hljs-comment">// high position padding with zeros</span>
              IRB.CreateZExt(IRB.CreateXorReduce(PrevCaller), IRB.getInt32Ty());
                <span class="hljs-comment">// CreateXorReduce(Value*): xor each element in vector Value* and return the xored result</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-comment">// ctx_k == 0</span>

#endif
        {

          <span class="hljs-comment">// load the context ID of the previous function and write to a</span>
          <span class="hljs-comment">// local variable on the stack</span>
          LoadInst *PrevCtxLoad = IRB.CreateLoad( <span class="hljs-comment">// PrevCtxLoad stores prev function context ID</span>
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
              IRB.getInt32Ty(),
#endif
              AFLContext);

          <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
          PrevCtxLoad-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                                   MDNode::get(C, None));
          PrevCtx = PrevCtxLoad;

        } <span class="hljs-comment">// end of if(ctx_k) else </span>

        <span class="hljs-comment">// does the function have calls? and is any of the calls larger than one basic block?</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;BB_2 : F) { <span class="hljs-comment">// traverse all BB in function F again </span>
            <span class="hljs-comment">// to check if F calls other functions needed to be instrumented</span>

          <span class="hljs-keyword">if</span> (has_calls) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// already found calls then break</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;IN : BB_2) { <span class="hljs-comment">// traverse instruction by instruction in function</span>

            CallInst *callInst = <span class="hljs-literal">nullptr</span>;
            <span class="hljs-keyword">if</span> ((callInst = dyn_cast&lt;CallInst&gt;(&amp;IN))) { <span class="hljs-comment">// safely transform &amp;IN to CallInst type</span>

              Function *Callee = callInst-&gt;getCalledFunction(); <span class="hljs-comment">// get the callee of instruction</span>
              <span class="hljs-keyword">if</span> (!Callee || Callee-&gt;size() &lt; function_minimum_size) 
                  <span class="hljs-comment">// if callee is nullptr || called function with little BB, then skip</span>
                <span class="hljs-keyword">continue</span>;
              <span class="hljs-keyword">else</span> { <span class="hljs-comment">// found one called function needed to be instrumented</span>

                has_calls = <span class="hljs-number">1</span>; <span class="hljs-comment">// set the flag has_calls = 1</span>
                <span class="hljs-keyword">break</span>;

              }

            }

          }

        } <span class="hljs-comment">// end of for (auto &amp;BB_2 : F)</span>

        <span class="hljs-comment">// if yes we store a context ID for this function in the global var</span>
        <span class="hljs-keyword">if</span> (has_calls) {
          <span class="hljs-comment">// random another new context ID</span>
          Value *NewCtx = ConstantInt::get(Int32Ty, AFL_R(map_size));
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
          <span class="hljs-keyword">if</span> (ctx_k) {
            <span class="hljs-comment">// uses mask vector to right shift the old vector </span>
            Value *ShuffledPrevCaller = IRB.CreateShuffleVector(
                PrevCaller, UndefValue::get(PrevCallerTy), <span class="hljs-comment">// UndefValue vector only occupy the places here</span>
                PrevCallerShuffleMask);
            <span class="hljs-comment">// and insert NewCtx into first place of PrevCaller vector</span>
            Value *UpdatedPrevCaller = IRB.CreateInsertElement(
                ShuffledPrevCaller, NewCtx, (<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">0</span>);

            StoreInst *Store = <span class="hljs-comment">// CreateStore(Value *Val, Value *Ptr): store Val to Ptr </span>
                IRB.CreateStore(UpdatedPrevCaller, AFLPrevCaller); <span class="hljs-comment">// update AFLPrevCaller with UpdatedPrevCaller</span>
            <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
            Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                               MDNode::get(C, None));

          } <span class="hljs-keyword">else</span> <span class="hljs-comment">// ctx_k == 0</span>

#endif
          {
            <span class="hljs-comment">// when disables context mode then xor PrevCtx with NewCtx </span>
            <span class="hljs-keyword">if</span> (ctx_str) NewCtx = IRB.CreateXor(PrevCtx, NewCtx);
            StoreInst *StoreCtx = IRB.CreateStore(NewCtx, AFLContext); <span class="hljs-comment">// update AFLContext with NewCtx</span>
            <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
            StoreCtx-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                                  MDNode::get(C, None));

          } <span class="hljs-comment">// end of if else</span>

        } <span class="hljs-comment">// end of has_calls</span>

      } <span class="hljs-comment">// end of if (instrument_ctx &amp;&amp; &amp;BB == &amp;F.getEntryBlock())</span>

      <span class="hljs-keyword">if</span> (AFL_R(<span class="hljs-number">100</span>) &gt;= inst_ratio) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// skip rest BB instrumentation if random &gt;= inst_ratio</span>

      <span class="hljs-comment">/* Make up cur_loc */</span>

      <span class="hljs-comment">// cur_loc++;</span>
      cur_loc = AFL_R(map_size); <span class="hljs-comment">// random cur_loc for current BB from 0 to map_size - 1</span>

<span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// ignore this bug fix code</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !(LLVM_VERSION_MAJOR == 6 &amp;&amp; LLVM_VERSION_MINOR == 0) || !defined __linux__</span>

      <span class="hljs-comment">// only instrument if this basic block is the destination of a previous</span>
      <span class="hljs-comment">// basic block that has multiple successors</span>
      <span class="hljs-comment">// this gets rid of ~5-10% of instrumentations that are unnecessary</span>
      <span class="hljs-comment">// result: a little more speed and less map pollution</span>
      <span class="hljs-keyword">int</span> more_than_one = <span class="hljs-number">-1</span>; <span class="hljs-comment">// flag: BB&apos;s pred_BB has more than one succ_BB  </span>
      <span class="hljs-comment">// fprintf(stderr, &quot;BB %u: &quot;, cur_loc);</span>
      <span class="hljs-keyword">for</span> (pred_iterator PI = pred_begin(&amp;BB), E = pred_end(&amp;BB); PI != E; ++PI) {

        BasicBlock *Pred = *PI;

        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// count for succ_BB  </span>
        <span class="hljs-keyword">if</span> (more_than_one == <span class="hljs-number">-1</span>) more_than_one = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// fprintf(stderr, &quot; %p=&gt;&quot;, Pred);</span>

        <span class="hljs-keyword">for</span> (succ_iterator SI = succ_begin(Pred), E = succ_end(Pred); SI != E; ++SI) {

          BasicBlock *Succ = *SI;

          <span class="hljs-keyword">if</span> (Succ != <span class="hljs-literal">NULL</span>) count++;

        }

        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) more_than_one = <span class="hljs-number">1</span>; <span class="hljs-comment">// succ_BB count is more than one </span>

      }

      <span class="hljs-comment">// fprintf(stderr, &quot; == %d\n&quot;, more_than_one);</span>
      <span class="hljs-keyword">if</span> (F.size() &gt; <span class="hljs-number">1</span> &amp;&amp; more_than_one != <span class="hljs-number">1</span>) {

        <span class="hljs-comment">// in CTX mode we have to restore the original context for the caller -</span>
        <span class="hljs-comment">// she might be calling other functions which need the correct CTX</span>
        <span class="hljs-keyword">if</span> (instrument_ctx &amp;&amp; has_calls) {

          Instruction *Inst = BB.getTerminator(); <span class="hljs-comment">// get the last instruction of BB</span>
          <span class="hljs-keyword">if</span> (isa&lt;ReturnInst&gt;(Inst) || isa&lt;ResumeInst&gt;(Inst)) { 
              <span class="hljs-comment">// only last inst is ret or resum type need to restore context</span>

            IRBuilder&lt;&gt; Post_IRB(Inst); <span class="hljs-comment">// define IRBuilder Post_IRB, which is right before Inst instruction</span>

            StoreInst *RestoreCtx;
  <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
            <span class="hljs-keyword">if</span> (ctx_k) <span class="hljs-comment">// restore the context ID to AFLPrevCaller when enables ctx_k</span>
              RestoreCtx = IRB.CreateStore(PrevCaller, AFLPrevCaller);
            <span class="hljs-keyword">else</span> <span class="hljs-comment">// restore the context ID to AFLContext when disables ctx_k</span>
  #endif
              RestoreCtx = Post_IRB.CreateStore(PrevCtx, AFLContext);
            <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
            RestoreCtx-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                                    MDNode::get(C, None));

          }

        } <span class="hljs-comment">// end of if (instrument_ctx &amp;&amp; has_calls)</span>

        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// skip instrumentation if pred_BB not ends with conditional jump</span>
          <span class="hljs-comment">// which means the current BB is not in branching path, so no need to instrument</span>

      } <span class="hljs-comment">// end of if (F.size() &gt; 1 &amp;&amp; more_than_one != 1)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

      ConstantInt *CurLoc; <span class="hljs-comment">// define constant CurLoc to store current BB location</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
      <span class="hljs-keyword">if</span> (ngram_size)
        CurLoc = ConstantInt::get(IntLocTy, cur_loc); <span class="hljs-comment">// when enables ngram then CurLoc type is IntLocTy</span>
      <span class="hljs-keyword">else</span>
#endif
        CurLoc = ConstantInt::get(Int32Ty, cur_loc); <span class="hljs-comment">// when disables ngram CurLoc type is Int32Ty</span>

      <span class="hljs-comment">/* Load prev_loc */</span>

      LoadInst *PrevLoc;

      <span class="hljs-keyword">if</span> (ngram_size) {

        PrevLoc = IRB.CreateLoad(
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
            PrevLocTy, <span class="hljs-comment">// if ngram enables then load PrevLoc as PrevLocTy type</span>
#endif
            AFLPrevLoc);

      } <span class="hljs-keyword">else</span> {

        PrevLoc = IRB.CreateLoad(
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
            IRB.getInt32Ty(), <span class="hljs-comment">// if ngram disables then load PrevLoc as Int32Ty type</span>
#endif
            AFLPrevLoc);

      }
      <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
      PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));
      Value *PrevLocTrans;

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
      <span class="hljs-comment">/* &quot;For efficiency, we propose to hash the tuple as a key into the
         hit_count map as (prev_block_trans &lt;&lt; 1) ^ curr_block_trans, where
         prev_block_trans = (block_trans_1 ^ ... ^ block_trans_(n-1)&quot; */</span>

      <span class="hljs-keyword">if</span> (ngram_size)
        PrevLocTrans = <span class="hljs-comment">// xor PrevLoc each element to introduce n gram BBs information</span>
            IRB.CreateZExt(IRB.CreateXorReduce(PrevLoc), IRB.getInt32Ty());
      <span class="hljs-keyword">else</span>
#endif
        PrevLocTrans = PrevLoc;

      <span class="hljs-keyword">if</span> (instrument_ctx)
        PrevLocTrans = <span class="hljs-comment">// xor PrevLocTrans with PrevCtx to introduce context-aware</span>
            IRB.CreateZExt(IRB.CreateXor(PrevLocTrans, PrevCtx), Int32Ty);
      <span class="hljs-keyword">else</span>
        PrevLocTrans = IRB.CreateZExt(PrevLocTrans, IRB.getInt32Ty());
</code></pre>
<p>&#x63D2;&#x6869;&#x4E4B;&#x540E;&#x4F1A;&#x66F4;&#x65B0; bitmap, &#x4E5F;&#x5C31;&#x662F;&#x76EE;&#x6807;&#x7A0B;&#x5E8F;&#x4E0E; fuzzer &#x7684;&#x5171;&#x4EAB;&#x5185;&#x5B58;, &#x53CD;&#x9988;&#x4FE1;&#x606F;&#x7531;&#x6B64;&#x4F20;&#x8F93;</p>
<pre><code class="lang-c">      <span class="hljs-comment">/* Load SHM pointer */</span>

      LoadInst *MapPtr = IRB.CreateLoad(
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
          PointerType::get(Int8Ty, <span class="hljs-number">0</span>),
#endif
          AFLMapPtr); <span class="hljs-comment">// load share memory ptr from AFLMapPtr with type i8*</span>
      <span class="hljs-comment">// insert nosanitize to tell A/M/TSan not to analyze the instruction</span>
      MapPtr-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));

      Value *MapPtrIdx; <span class="hljs-comment">// share memory (bitmap) index ptr</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
      <span class="hljs-keyword">if</span> (ngram_size)
        MapPtrIdx = IRB.CreateGEP( <span class="hljs-comment">// CreateGEP(type, ptr1, ptr2): ptr1 + ptr2</span>
            Int8Ty, MapPtr,
            IRB.CreateZExt(
                IRB.CreateXor(PrevLocTrans, IRB.CreateZExt(CurLoc, Int32Ty)),
                Int32Ty));
      <span class="hljs-keyword">else</span>
#endif
        MapPtrIdx = IRB.CreateGEP(
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
            Int8Ty,
#endif
            MapPtr, IRB.CreateXor(PrevLocTrans, CurLoc));
      <span class="hljs-comment">// logic above is like this: MapPtrIdx = MapPtr + ((PrevLoc ^ CurLoc) &amp; 0xFFFF)</span>

      <span class="hljs-comment">/* Update bitmap */</span>

      <span class="hljs-keyword">if</span> (use_threadsafe_counters) {                              <span class="hljs-comment">/* Atomic */</span>
        <span class="hljs-comment">// logic of function below is like: bitmap[MapPtrIdx] += 1;</span>
        IRB.CreateAtomicRMW(llvm::AtomicRMWInst::BinOp::Add, MapPtrIdx, One,
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">13</span>
                            llvm::MaybeAlign(<span class="hljs-number">1</span>),
#endif
                            llvm::AtomicOrdering::Monotonic);
        <span class="hljs-comment">/*

                }

        */</span>

      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// not Atomic operations</span>

        LoadInst *Counter = IRB.CreateLoad(
#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= <span class="hljs-number">14</span>
            IRB.getInt8Ty(),
#endif
            MapPtrIdx);
        Counter-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));

        Value *Incr = IRB.CreateAdd(Counter, One); <span class="hljs-comment">// Incr = bitmap[MapPtrIdx] + 1;</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 9</span>
        <span class="hljs-keyword">if</span> (!skip_nozero) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-keyword">if</span> (neverZero_counters_str != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// if enables neverzero then skip 0 counter value</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
          <span class="hljs-comment">/* hexcoder: Realize a counter that skips zero during overflow.
           * Once this counter reaches its maximum value, it next increments to
           * 1
           *
           * Instead of
           * Counter + 1 -&gt; Counter
           * we inject now this
           * Counter + 1 -&gt; {Counter, OverflowFlag}
           * Counter + OverflowFlag -&gt; Counter
           */</span>

          ConstantInt *Zero = ConstantInt::get(Int8Ty, <span class="hljs-number">0</span>); <span class="hljs-comment">// get constant 0 with type i8</span>
          <span class="hljs-keyword">auto</span>         cf = IRB.CreateICmpEQ(Incr, Zero); <span class="hljs-comment">// if Incr == 0, means overflow</span>
          <span class="hljs-keyword">auto</span>         carry = IRB.CreateZExt(cf, Int8Ty); <span class="hljs-comment">// carry = 1 when Incr == 0</span>
          Incr = IRB.CreateAdd(Incr, carry); <span class="hljs-comment">// Incr plus carry to avoid 0 value</span>

        }

        IRB.CreateStore(Incr, MapPtrIdx)
            -&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));

      }                                                  <span class="hljs-comment">/* non atomic case */</span>

      <span class="hljs-comment">/* Update prev_loc history vector (by placing cur_loc at the head of the
         vector and shuffle the other elements back by one) */</span>

      StoreInst *Store;

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
      <span class="hljs-keyword">if</span> (ngram_size) {

        Value *ShuffledPrevLoc = IRB.CreateShuffleVector(
            PrevLoc, UndefValue::get(PrevLocTy), PrevLocShuffleMask);
        Value *UpdatedPrevLoc = IRB.CreateInsertElement(
            ShuffledPrevLoc, IRB.CreateLShr(CurLoc, (<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span>), (<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">0</span>);
            <span class="hljs-comment">// CreateLShr(val1, val2): val1 &gt;&gt; val2  </span>
        Store = IRB.CreateStore(UpdatedPrevLoc, AFLPrevLoc);
        Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));

      } <span class="hljs-keyword">else</span>

#endif
      {

        Store = IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="hljs-number">1</span>),
                                AFLPrevLoc);
        Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));

      }

      <span class="hljs-comment">// in CTX mode we have to restore the original context for the caller -</span>
      <span class="hljs-comment">// she might be calling other functions which need the correct CTX.</span>
      <span class="hljs-comment">// Currently this is only needed for the Ubuntu clang-6.0 bug</span>
      <span class="hljs-keyword">if</span> (instrument_ctx &amp;&amp; has_calls) { <span class="hljs-comment">// when enables context then restore the context of BB</span>

        Instruction *Inst = BB.getTerminator();
        <span class="hljs-keyword">if</span> (isa&lt;ReturnInst&gt;(Inst) || isa&lt;ResumeInst&gt;(Inst)) {

          IRBuilder&lt;&gt; Post_IRB(Inst);

          StoreInst *RestoreCtx;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AFL_HAVE_VECTOR_INTRINSICS</span>
          <span class="hljs-keyword">if</span> (ctx_k)
            RestoreCtx = IRB.CreateStore(PrevCaller, AFLPrevCaller);
          <span class="hljs-keyword">else</span>
#endif
            RestoreCtx = Post_IRB.CreateStore(PrevCtx, AFLContext);
          RestoreCtx-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>),
                                  MDNode::get(C, None));

        }

      }

      inst_blocks++; <span class="hljs-comment">// successful instrumentation count++ </span>

    } <span class="hljs-comment">// end of if (instrument_ctx &amp;&amp; has_calls)</span>
</code></pre>
<p>&#x6700;&#x540E;, &#x662F;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x548C;&#x8BA1;&#x6570;&#x5668;&#x66F4;&#x65B0;&#x7684;&#x65B0;&#x7248;&#x4EE3;&#x7801;, &#x4E3B;&#x8981;&#x903B;&#x8F91;&#x662F;&#x4F7F;&#x7528; CAS (Compare-And-Swap) &#x5FAA;&#x73AF;&#x66FF;&#x4EE3;&#x539F;&#x672C;&#x7684; <code>++</code> &#x64CD;&#x4F5C;. &#x4F18;&#x70B9;&#x662F;&#x5E76;&#x53D1;&#x66F4;&#x5B89;&#x5168;, &#x907F;&#x514D;&#x8BA1;&#x6570;&#x5668;&#x4E3A; 0 &#x7684;&#x95EE;&#x9898;, &#x7F3A;&#x70B9;&#x662F;&#x6548;&#x7387;&#x6BD4; <code>++</code> &#x66F4;&#x4F4E;, &#x76EE;&#x524D;&#x4F5C;&#x4E3A;&#x672A;&#x6765;&#x8BA1;&#x5212;&#x4E4B;&#x4E00;, &#x5C1A;&#x672A;&#x542F;&#x7528;. </p>
<pre><code class="lang-c">#if 0
    if (use_threadsafe_counters) {                       /* Atomic NeverZero */
      // handle the list of registered blocks to instrument
      for (auto val : todo) {

        /* hexcoder: Realize a thread-safe counter that skips zero during
         * overflow. Once this counter reaches its maximum value, it next
         * increments to 1
         * ...
         */

        Value *              MapPtrIdx = val;
        Instruction *        MapPtrIdxInst = cast&lt;Instruction&gt;(val);
        BasicBlock::iterator it0(&amp;(*MapPtrIdxInst));
        ++it0;
        IRBuilder&lt;&gt; IRB(&amp;(*it0));

        // load the old counter value atomically
        LoadInst *Counter = IRB.CreateLoad(
  #if LLVM_VERSION_MAJOR &gt;= 14
        IRB.getInt8Ty(),
  #endif
        MapPtrIdx);
        Counter-&gt;setAlignment(llvm::Align());
        Counter-&gt;setAtomic(llvm::AtomicOrdering::Monotonic);
        Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

        BasicBlock *BB = IRB.GetInsertBlock();
        // insert a basic block with the corpus of a do while loop
        // the calculation may need to repeat, if atomic compare_exchange is not
        // successful

        BasicBlock::iterator it(*Counter);
        it++;  // split after load counter
        BasicBlock *end_bb = BB-&gt;splitBasicBlock(it);
        end_bb-&gt;setName(&quot;injected&quot;);

        // insert the block before the second half of the split
        BasicBlock *do_while_bb =
            BasicBlock::Create(C, &quot;injected&quot;, end_bb-&gt;getParent(), end_bb);

        // set terminator of BB from target end_bb to target do_while_bb
        auto term = BB-&gt;getTerminator();
        BranchInst::Create(do_while_bb, BB);
        term-&gt;eraseFromParent();

        // continue to fill instructions into the do_while loop
        IRB.SetInsertPoint(do_while_bb, do_while_bb-&gt;getFirstInsertionPt());

        PHINode *PN = IRB.CreatePHI(Int8Ty, 2);

        // compare with maximum value 0xff
        auto *Cmp = IRB.CreateICmpEQ(Counter, ConstantInt::get(Int8Ty, -1));

        // increment the counter
        Value *Incr = IRB.CreateAdd(Counter, One);

        // select the counter value or 1
        auto *Select = IRB.CreateSelect(Cmp, One, Incr);

        // try to save back the new counter value
        auto *CmpXchg = IRB.CreateAtomicCmpXchg(
            MapPtrIdx, PN, Select, llvm::AtomicOrdering::Monotonic,
            llvm::AtomicOrdering::Monotonic);
        CmpXchg-&gt;setAlignment(llvm::Align());
        CmpXchg-&gt;setWeak(true);
        CmpXchg-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

        // get the result of trying to update the Counter
        Value *Success =
            IRB.CreateExtractValue(CmpXchg, ArrayRef&lt;unsigned&gt;({1}));
        // get the (possibly updated) value of Counter
        Value *OldVal =
            IRB.CreateExtractValue(CmpXchg, ArrayRef&lt;unsigned&gt;({0}));

        // initially we use Counter
        PN-&gt;addIncoming(Counter, BB);
        // on retry, we use the updated value
        PN-&gt;addIncoming(OldVal, do_while_bb);

        // if the cmpXchg was not successful, retry
        IRB.CreateCondBr(Success, end_bb, do_while_bb);

      }

    }

#endif // end of #if 0

  } // end of for (auto &amp;F : M)

  /*
    // This is currently disabled because we not only need to create/insert a
    // function (easy), but also add it as a constructor with an ID &lt; 5
    ...
  */

  /* Say something nice. */

  if (!be_quiet) { // print out information for debugging

    if (!inst_blocks)
      WARNF(&quot;No instrumentation targets found.&quot;);
    else {

      char modeline[100];
      snprintf(modeline, sizeof(modeline), &quot;%s%s%s%s%s%s&quot;,
               getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; : &quot;non-hardened&quot;,
               getenv(&quot;AFL_USE_ASAN&quot;) ? &quot;, ASAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_MSAN&quot;) ? &quot;, MSAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_CFISAN&quot;) ? &quot;, CFISAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_TSAN&quot;) ? &quot;, TSAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_UBSAN&quot;) ? &quot;, UBSAN&quot; : &quot;&quot;);
      OKF(&quot;Instrumented %d locations (%s mode, ratio %u%%).&quot;, inst_blocks,
          modeline, inst_ratio);

    }

  }
</code></pre>
<h2 id="reference">Reference</h2>
<p>[1] <a href="https://github.com/AFLplusplus/AFLplusplus" target="_blank">https://github.com/AFLplusplus/AFLplusplus</a></p>
<p>[2] <a href="https://nyx-fuzz.com/papers/redqueen.pdf" target="_blank">https://nyx-fuzz.com/papers/redqueen.pdf</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="aflpp_src_reading_II.html" class="navigation navigation-prev " aria-label="Previous page: AFLpp Src Reading II - Forkserver">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="aflpp_new_test.html" class="navigation navigation-next " aria-label="Next page: AFL++ Add New Test">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"AFLpp Src Reading III - Instrumentation","level":"3.1.6","depth":2,"next":{"title":"AFL++ Add New Test","level":"3.1.7","depth":2,"path":"fuzzing/aflpp_new_test.md","ref":"fuzzing/aflpp_new_test.md","articles":[]},"previous":{"title":"AFLpp Src Reading II - Forkserver","level":"3.1.5","depth":2,"path":"fuzzing/aflpp_src_reading_II.md","ref":"fuzzing/aflpp_src_reading_II.md","articles":[]},"dir":"ltr"},"config":{"plugins":["theme-default","toggle-chapters","katex","sharing","lunr","search","livereload","fontsettings","highlight","theme-comscore"],"styles":{"website":"styles/website.css"},"pluginsConfig":{"livereload":{},"search":{},"lunr":{"ignoreSpecialCharacters":false,"maxIndexSize":1000000},"katex":{},"fontsettings":{"family":"sans","size":2,"theme":"white","fontFamily":"Arial Unicode MS"},"highlight":{},"theme-comscore":{},"sharing":{"all":["facebook","google","twitter","weibo","instapaper"],"facebook":true,"google":false,"instapaper":false,"twitter":true,"vk":false,"weibo":false},"theme-default":{"showLevel":false,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"toggle-chapters":{"toggle":true}},"theme":"default","author":"fa1c4","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"FA1C4 PATHs","language":"en","gitbook":"*","description":"Paths of fa1c4 to strive"},"file":{"path":"fuzzing/aflpp_src_reading_III.md","mtime":"2025-06-02T14:27:49.066Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-07-03T07:46:23.475Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-toggle-chapters/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

