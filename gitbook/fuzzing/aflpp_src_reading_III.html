
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>AFLpp Src Reading III - Instrumentation Â· FA1C4 PATHs</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="fa1c4">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-toggle-chapters/toggle.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="aflpp_new_test.html" />
    
    
    <link rel="prev" href="aflpp_src_reading_II.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../papers/">
            
                <a href="../papers/">
            
                    
                    Papers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../papers/SoK_Prudent_Evaluation_Practices_for_Fuzzing.html">
            
                <a href="../papers/SoK_Prudent_Evaluation_Practices_for_Fuzzing.html">
            
                    
                    SoK: Prudent Evaluation Practices for Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../papers/FOX.html">
            
                <a href="../papers/FOX.html">
            
                    
                    FOX: Coverage-guided Fuzzing as Online Stochastic Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../papers/On_Understanding.html">
            
                <a href="../papers/On_Understanding.html">
            
                    
                    On Understanding and Forecasting Fuzzers Performance with Static Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../papers/autofz.html">
            
                <a href="../papers/autofz.html">
            
                    
                    autofz: Automated Fuzzer Composition at Runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../papers/Fuzz_to_the_Future.html">
            
                <a href="../papers/Fuzz_to_the_Future.html">
            
                    
                    Fuzz to the Future: Uncovering Occluded Future Vulnerabilities via Robust Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../papers/DSFuzz.html">
            
                <a href="../papers/DSFuzz.html">
            
                    
                    DSFuzz: Detecting Deep State Bugs with Dependent State Exploration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../papers/Rubick.html">
            
                <a href="../papers/Rubick.html">
            
                    
                    Automata-Guided Control-Flow-Sensitive Fuzz Driver Generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../papers/Fuzz4All.html">
            
                <a href="../papers/Fuzz4All.html">
            
                    
                    Fuzz4All: Universal Fuzzing with Large Language Models
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../papers/kag.html">
            
                <a href="../papers/kag.html">
            
                    
                    KAG: Boosting LLMs in Professional Domains via Knowledge Augmented Generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../papers/graphuzz.html">
            
                <a href="../papers/graphuzz.html">
            
                    
                    Graphuzz: Data-driven Seed Scheduling for Coverage-guided Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="../papers/Seed_Selection.html">
            
                <a href="../papers/Seed_Selection.html">
            
                    
                    Seed Selection for Successful Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="../papers/belieffuzz.html">
            
                <a href="../papers/belieffuzz.html">
            
                    
                    Balance Seed Scheduling via Monte Carlo Planning
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="../papers/K_Scheduler.html">
            
                <a href="../papers/K_Scheduler.html">
            
                    
                    Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="../papers/entropic.html">
            
                <a href="../papers/entropic.html">
            
                    
                    Boosting Fuzzer Efficiency: An Information Theoretic Perspective
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="../papers/FuzzInMem.html">
            
                <a href="../papers/FuzzInMem.html">
            
                    
                    FuzzInMem: Fuzzing Programs via In-memory Structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="../papers/AFLpp.html">
            
                <a href="../papers/AFLpp.html">
            
                    
                    AFL++: Combining Incremental Steps of Fuzzing Research
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="../papers/DDFuzz.html">
            
                <a href="../papers/DDFuzz.html">
            
                    
                    Fuzzing with Data Dependency Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.18" data-path="../papers/Hier.html">
            
                <a href="../papers/Hier.html">
            
                    
                    Reinforcement Learning-based Hierarchical Seed Scheduling for Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.19" data-path="../papers/LLM_Fuzzing_BusyBox.html">
            
                <a href="../papers/LLM_Fuzzing_BusyBox.html">
            
                    
                    Fuzzing BusyBox: Leveraging LLM and Crash Reuse for Embedded Bug Unearthing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.20" data-path="../papers/llm2vec.html">
            
                <a href="../papers/llm2vec.html">
            
                    
                    LLM2Vec: Large Language Models Are Secretly Powerful Text Encoders
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.21" data-path="../papers/ShapFuzz.html">
            
                <a href="../papers/ShapFuzz.html">
            
                    
                    SHAPFUZZ: Efficient Fuzzing via Shapley-Guided Byte Selection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.22" data-path="../papers/TortoiseFuzz.html">
            
                <a href="../papers/TortoiseFuzz.html">
            
                    
                    Not All Coverage Measurements Are Equal: Fuzzing by Coverage Accounting for Input Prioritization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.23" data-path="../papers/prefix_guided_execution.html">
            
                <a href="../papers/prefix_guided_execution.html">
            
                    
                    Accelerating Fuzzing through Prefix-Guided Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.24" data-path="../papers/Fuzztastic.html">
            
                <a href="../papers/Fuzztastic.html">
            
                    
                    Extrapolating Coverage Rate in Greybox Fuzzing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.25" data-path="../papers/ProRec.html">
            
                <a href="../papers/ProRec.html">
            
                    
                    Source Code Foundation Models are Transferable Binary Analysis Knowledge Bases
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../linux/">
            
                <a href="../linux/">
            
                    
                    Linux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../linux/rust_elementary_I.html">
            
                <a href="../linux/rust_elementary_I.html">
            
                    
                    Rust Elementary I
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../linux/rust_elementary_II.html">
            
                <a href="../linux/rust_elementary_II.html">
            
                    
                    Rust Elementary II
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../linux/rust_elementary_III.html">
            
                <a href="../linux/rust_elementary_III.html">
            
                    
                    Rust Elementary III
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="../linux/rust_elementary_IV.html">
            
                <a href="../linux/rust_elementary_IV.html">
            
                    
                    Rust Elementary IV
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="../linux/rust_elementary_V.html">
            
                <a href="../linux/rust_elementary_V.html">
            
                    
                    Rust Elementary V
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="../linux/rust_elementary_VI.html">
            
                <a href="../linux/rust_elementary_VI.html">
            
                    
                    Rust Elementary VI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.7" data-path="../linux/docker_sources_switch.html">
            
                <a href="../linux/docker_sources_switch.html">
            
                    
                    Docker Sources Switch
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="./">
            
                <a href="./">
            
                    
                    Fuzzing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="AFLpp_build_on_Magma.html">
            
                <a href="AFLpp_build_on_Magma.html">
            
                    
                    AFLpp build for Magma
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="fuzzbench_build.html">
            
                <a href="fuzzbench_build.html">
            
                    
                    FuzzBench Build
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="fuzzbench_new_fuzzer.html">
            
                <a href="fuzzbench_new_fuzzer.html">
            
                    
                    Fuzzbench new Fuzzer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="aflpp_src_reading_I.html">
            
                <a href="aflpp_src_reading_I.html">
            
                    
                    AFLpp Src Reading I - History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="aflpp_src_reading_II.html">
            
                <a href="aflpp_src_reading_II.html">
            
                    
                    AFLpp Src Reading II - Forkserver
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.1.6" data-path="aflpp_src_reading_III.html">
            
                <a href="aflpp_src_reading_III.html">
            
                    
                    AFLpp Src Reading III - Instrumentation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.7" data-path="aflpp_new_test.html">
            
                <a href="aflpp_new_test.html">
            
                    
                    AFL++ Add New Test
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.8" data-path="aflpp_custom_mutator.html">
            
                <a href="aflpp_custom_mutator.html">
            
                    
                    AFL++ Custom Mutator (python)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../pwn/">
            
                <a href="../pwn/">
            
                    
                    Pwn
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../pwn/glibc_IO_FILE_exploitation.html">
            
                <a href="../pwn/glibc_IO_FILE_exploitation.html">
            
                    
                    Glibc _IO_FILE Exploitation Introduction
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../reverse/">
            
                <a href="../reverse/">
            
                    
                    Reverse
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" data-path="../reverse/IDAPro_cheatsheet_7x.html">
            
                <a href="../reverse/IDAPro_cheatsheet_7x.html">
            
                    
                    IDAPro Cheat Sheet 7.7
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../theory/">
            
                <a href="../theory/">
            
                    
                    Theory
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../theory/prac_statistics.html">
            
                <a href="../theory/prac_statistics.html">
            
                    
                    Practical Statistics
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../LLM/">
            
                <a href="../LLM/">
            
                    
                    LLM
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" data-path="../latex/">
            
                <a href="../latex/">
            
                    
                    Latex
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" data-path="../latex/awes_table.html">
            
                <a href="../latex/awes_table.html">
            
                    
                    latex awesome table templates
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="9.1" data-path="../shell/">
            
                <a href="../shell/">
            
                    
                    Shell
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="9.1.1" data-path="../shell/shell_programming_basic.html">
            
                <a href="../shell/shell_programming_basic.html">
            
                    
                    shell programming basic
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.2" data-path="../shell/shell_programming_techs_I.html">
            
                <a href="../shell/shell_programming_techs_I.html">
            
                    
                    shell programming techs I
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >AFLpp Src Reading III - Instrumentation</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="afl-source-code-reading-iii---instrumentation">AFL++ Source Code Reading III - Instrumentation</h1>
<p>&#x672C;&#x6587;&#x89E3;&#x6790; AFL++ &#x63D2;&#x6869;&#x90E8;&#x5206;&#x7684;&#x6E90;&#x4EE3;&#x7801;</p>
<p>AFL++ &#x4ECE; 3.00c &#x7248;&#x672C;&#x5F00;&#x59CB;&#x7EDF;&#x4E00;&#x6240;&#x6709;&#x63D2;&#x6869;&#x7F16;&#x8BD1;&#x5668;&#x5230; <code>afl-cc</code>, &#x867D;&#x7136;&#x7F16;&#x8BD1; AFL++ &#x4E4B;&#x540E;&#x4F9D;&#x7136;&#x6709; <code>afl-clang*</code> &#x4E4B;&#x7C7B;&#x7684;&#x7F16;&#x8BD1;&#x5668;, &#x4F46;&#x90FD;&#x662F;&#x94FE;&#x63A5;&#x5230; <code>afl-cc</code> &#x7684;&#x94FE;&#x63A5;&#x6587;&#x4EF6;, &#x5B9E;&#x9645;&#x8C03;&#x7528;&#x7684;&#x90FD;&#x662F; <code>afl-cc</code>. AFL++ &#x652F;&#x6301;&#x7684;&#x63D2;&#x6869;&#x65B9;&#x5F0F;&#x5F88;&#x591A;, &#x672C;&#x7BC7;&#x4E3B;&#x8981;&#x5173;&#x6CE8; llvm mode. </p>
<h2 id="overview">Overview</h2>
<p>AFL++ &#x652F;&#x6301;&#x7684;&#x63D2;&#x6869;&#x9009;&#x62E9;&#x5982;&#x4E0B;</p>
<table>
<thead>
<tr>
<th>Instrumentation</th>
<th>Desription</th>
</tr>
</thead>
<tbody>
<tr>
<td>CmpLog</td>
<td>Enables logging of comparison operands in a shared memory. Used by various mutators, like redqueen [2].</td>
</tr>
<tr>
<td>GCC-based</td>
<td><code>afl-gcc-fast</code> and <code>afl-g++-fast</code>. True compiler-level instrumentation.</td>
</tr>
<tr>
<td>Injection</td>
<td>Proof-of-concept implementation to additionally hunt for injection vulnerabilities. It works by instrumenting calls to specific functions and parsing the query parameter for a specific unescaped dictionary string, and if detected, crashes the target.</td>
</tr>
<tr>
<td>Partial Instrumentation</td>
<td>Testing complex programs where only a part of the program is the fuzzing target, it often helps to only instrument the necessary parts of the program, leaving the rest uninstrumented.</td>
</tr>
<tr>
<td>laf-intel</td>
<td>Make some code transformations that help AFL++ to enter conditional blocks, where conditions consist of comparisons of large values.</td>
</tr>
<tr>
<td>Fast LLVM-based</td>
<td><code>afl-clang-fast</code> and <code>afl-clang-fast++</code>. True compiler-level instrumentation. Requires llvm-3.8 up to 17.</td>
</tr>
<tr>
<td>lto</td>
<td>Collision free instrumentation and is faster than PCGUARD. Requires LLVM 12+.</td>
</tr>
<tr>
<td>persistent mode</td>
<td>AFL++ fuzzes a target multiple times in a single forked process, instead of forking a new process for each fuzz execution. Persistent mode requires that the target can be called in one or more functions, and that its state can be completely reset so that multiple calls can be performed without resource leaks, and that earlier runs will have no impact on future runs.</td>
</tr>
</tbody>
</table>
<p>llvm mode &#x7684;&#x6838;&#x5FC3;&#x6E90;&#x6587;&#x4EF6;</p>
<ul>
<li><strong>afl-llvm-common.*</strong>: LLVM &#x63D2;&#x6869;&#x7684;&#x516C;&#x5171;&#x8F85;&#x52A9;&#x4EE3;&#x7801;, &#x5C01;&#x88C5;&#x591A;&#x4E2A;&#x63D2;&#x6869; Pass &#x5171;&#x7528;&#x7684;&#x51FD;&#x6570;&#x548C;&#x6570;&#x636E;&#x7ED3;&#x6784;, &#x6BD4;&#x5982;&#x63D2;&#x6869;&#x70B9;&#x7BA1;&#x7406;&#x3001;&#x8F85;&#x52A9;&#x5DE5;&#x5177;&#x51FD;&#x6570;&#x7B49;. </li>
<li><strong>afl-llvm-pass.so.cc</strong>: LLVM &#x63D2;&#x6869; Pass &#x7684;&#x5B9E;&#x73B0;&#x6587;&#x4EF6;, &#x5B9A;&#x4E49;&#x5728; LLVM &#x7F16;&#x8BD1;&#x94FE;&#x4E2D;&#x63D2;&#x5165;&#x8986;&#x76D6;&#x7387;&#x4EE3;&#x7801;&#x7684;&#x903B;&#x8F91;, &#x4E3B;&#x8981;&#x8D1F;&#x8D23;&#x63D2;&#x5165;&#x8BA1;&#x6570;&#x70B9;, &#x8BB0;&#x5F55;&#x6267;&#x884C;&#x8DEF;&#x5F84;&#x4FE1;&#x606F;. </li>
<li><strong>afl-compiler-rt.o.c (afl-llvm-rt.o.c in old afl)</strong>: AFL++ &#x7684;&#x8FD0;&#x884C;&#x65F6;&#x5E93;&#x6587;&#x4EF6;, &#x63D0;&#x4F9B;&#x8BA1;&#x6570;&#x5668;&#x66F4;&#x65B0;&#x3001;&#x5171;&#x4EAB;&#x5185;&#x5B58;&#x64CD;&#x4F5C;&#x7B49;&#x63D2;&#x6869;&#x65F6;&#x6240;&#x9700;&#x7684;&#x5E95;&#x5C42;&#x529F;&#x80FD;</li>
</ul>
<h2 id="afl-compiler-rtoc">afl-compiler-rt.o.c</h2>
<h3 id="&#x5168;&#x5C40;&#x53D8;&#x91CF;">&#x5168;&#x5C40;&#x53D8;&#x91CF;</h3>
<pre><code class="lang-c"><span class="hljs-comment">// buffer for share memory data &amp; execution counter </span>
<span class="hljs-keyword">static</span> u8  __afl_area_initial[MAP_INITIAL_SIZE];

<span class="hljs-comment">// __afl_area_ptr* points to memory where instrumentation code writing the data</span>
<span class="hljs-keyword">static</span> u8 *__afl_area_ptr_dummy = __afl_area_initial;
<span class="hljs-keyword">static</span> u8 *__afl_area_ptr_backup = __afl_area_initial;
u8        *__afl_area_ptr = __afl_area_initial;

<span class="hljs-comment">// point to mutation dictionary</span>
u8        *__afl_dictionary;
u32 __afl_dictionary_len;

<span class="hljs-comment">// points to testcase buffer </span>
u8        *__afl_fuzz_ptr;
<span class="hljs-comment">// the length of testcase input buffer</span>
<span class="hljs-keyword">static</span> u32 __afl_fuzz_len_dummy;
u32       *__afl_fuzz_len = &amp;__afl_fuzz_len_dummy;

<span class="hljs-comment">// flag shows whether enables sharedmem fuzzing</span>
<span class="hljs-keyword">int</span>        __afl_sharedmem_fuzzing __attribute__((weak));

<span class="hljs-comment">// the last location of instrumentation</span>
u32 __afl_final_loc;
<span class="hljs-comment">// the first location of valid instrumentation</span>
u32 __afl_first_final_loc;

<span class="hljs-comment">// share memory size default 2^16 == 64 KB == 65536</span>
u32 __afl_map_size = MAP_SIZE;
<span class="hljs-comment">// points to mappings of share memory coverage</span>
u64 __afl_map_addr;

<span class="hljs-comment">// compatible with old version of forkserver (ignored)</span>
u32 __afl_old_forkserver;

<span class="hljs-comment">//...</span>

<span class="hljs-comment">/* 1 if we are running in afl, and the forkserver was started, else 0 */</span>
u32 __afl_connected = <span class="hljs-number">0</span>;

<span class="hljs-comment">// for the __AFL_COVERAGE_ON/__AFL_COVERAGE_OFF features to work:</span>
<span class="hljs-keyword">int</span>        __afl_selective_coverage __attribute__((weak)); <span class="hljs-comment">// whether enables selective coverage</span>
<span class="hljs-keyword">int</span>        __afl_selective_coverage_start_off __attribute__((weak)); <span class="hljs-comment">// disables selective coverage from beginning</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __afl_selective_coverage_temp = <span class="hljs-number">1</span>; <span class="hljs-comment">// temp state of selective coverage</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)</span>
PREV_LOC_T __afl_prev_loc[NGRAM_SIZE_MAX];
PREV_LOC_T __afl_prev_caller[CTX_MAX_K];
u32        __afl_prev_ctx;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
__thread PREV_LOC_T __afl_prev_loc[NGRAM_SIZE_MAX]; <span class="hljs-comment">// context aware coverage</span>
__thread PREV_LOC_T __afl_prev_caller[CTX_MAX_K]; <span class="hljs-comment">// call stack aware coverage </span>
__thread u32        __afl_prev_ctx; <span class="hljs-comment">// ID of context</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-comment">// mapping for following current comparing instruction</span>
<span class="hljs-keyword">struct</span> cmp_map *__afl_cmp_map;
<span class="hljs-keyword">struct</span> cmp_map *__afl_cmp_map_backup;
<span class="hljs-comment">// log length of comparing instructions</span>
<span class="hljs-keyword">static</span> u8 __afl_cmplog_max_len = <span class="hljs-number">32</span>;  <span class="hljs-comment">// 16-32</span>

<span class="hljs-comment">// child process ID for forkserver mode</span>
<span class="hljs-keyword">static</span> s32 child_pid;
<span class="hljs-comment">// pointer for recovering signal</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">void</span> <span class="hljs-params">(*old_sigterm_handler)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> </span>= <span class="hljs-number">0</span>;

<span class="hljs-comment">/* Running in persistent mode? */</span>
<span class="hljs-keyword">static</span> u8 is_persistent;

<span class="hljs-comment">/* Are we in sancov mode? */</span>
<span class="hljs-keyword">static</span> u8 _is_sancov;

<span class="hljs-comment">/* Debug? */</span>
<span class="hljs-comment">/*static*/</span> u32 __afl_debug;

<span class="hljs-comment">/* Already initialized markers to avoid re-initialization */</span>
u32 __afl_already_initialized_shm;
u32 __afl_already_initialized_forkserver;
u32 __afl_already_initialized_first;
u32 __afl_already_initialized_second;
u32 __afl_already_initialized_early;
u32 __afl_already_initialized_init;

<span class="hljs-comment">/* Dummy pipe for area_is_valid() */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __afl_dummy_fd[<span class="hljs-number">2</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">2</span>};
</code></pre>
<h3 id="&#x7ED3;&#x6784;&#x4F53;">&#x7ED3;&#x6784;&#x4F53;</h3>
<pre><code class="lang-c"><span class="hljs-comment">// information for PCGuard coverage</span>
<span class="hljs-keyword">struct</span> <span class="hljs-keyword">afl_module_info_t</span> {

  <span class="hljs-comment">// A unique id starting with 0</span>
  u32 id;

  <span class="hljs-comment">// Name and base address of the module</span>
  <span class="hljs-keyword">char</span>     *name;
  <span class="hljs-keyword">uintptr_t</span> base_address;

  <span class="hljs-comment">// PC Guard start/stop</span>
  u32 *start;
  u32 *stop;

  <span class="hljs-comment">// PC Table begin/end</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_beg;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> *pcs_end;

  u8 mapped; <span class="hljs-comment">// whether mapped or not</span>

  <span class="hljs-keyword">afl_module_info_t</span> *next; <span class="hljs-comment">// next pointer: link data structure organizes multi modules</span>

};

<span class="hljs-comment">// assists for coverage</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {

  <span class="hljs-keyword">uintptr_t</span> PC, PCFlags;

} PCTableEntry;

<span class="hljs-comment">// header pointer points to module coverage link</span>
<span class="hljs-keyword">afl_module_info_t</span> *__afl_module_info = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// pc mapping table size</span>
u32        __afl_pcmap_size = <span class="hljs-number">0</span>;
<span class="hljs-comment">// points to program counter array</span>
<span class="hljs-keyword">uintptr_t</span> *__afl_pcmap_ptr = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// filtering the area where we want to skip instrumentation</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {

  <span class="hljs-keyword">uintptr_t</span> start; <span class="hljs-comment">// start of skip area</span>
  u32       len; <span class="hljs-comment">// length of skip area</span>

} FilterPCEntry;
u32            __afl_filter_pcs_size = <span class="hljs-number">0</span>; <span class="hljs-comment">// number of areas</span>
FilterPCEntry *__afl_filter_pcs = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// filtering arrays pointer</span>
u8            *__afl_filter_pcs_module = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// filtering module pointer</span>
</code></pre>
<h3 id="share-memory">Share Memory</h3>
<pre><code class="lang-c"><span class="hljs-comment">/* SHM fuzzing setup for store testcase input */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __afl_map_shm_fuzz() {
  <span class="hljs-comment">// get the id of share memory of input </span>
  <span class="hljs-keyword">char</span> *id_str = getenv(SHM_FUZZ_ENV_VAR);
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (id_str) {

    u8 *<span class="hljs-built_in">map</span> = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// selet share memory mode by USEMMAP</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>         shm_fd = <span class="hljs-number">-1</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shm_open() failed for fuzz\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-built_in">map</span> =
        (u8 *)mmap(<span class="hljs-number">0</span>, MAX_FILE + <span class="hljs-keyword">sizeof</span>(u32), PROT_READ, MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);
    <span class="hljs-built_in">map</span> = (u8 *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-comment">// ...</span>

    __afl_fuzz_len = (u32 *)<span class="hljs-built_in">map</span>;
    __afl_fuzz_ptr = <span class="hljs-built_in">map</span> + <span class="hljs-keyword">sizeof</span>(u32);

    <span class="hljs-comment">// ...</span>

  } <span class="hljs-keyword">else</span> {

    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: variable for fuzzing shared memory is not set\n&quot;</span>);
    send_forkserver_error(FS_ERROR_SHM_OPEN);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

  }

}


<span class="hljs-comment">/* SHM setup. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __afl_map_shm(<span class="hljs-keyword">void</span>) {

  <span class="hljs-keyword">if</span> (__afl_already_initialized_shm) <span class="hljs-keyword">return</span>;
  __afl_already_initialized_shm = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// if we are not running in afl ensure the map exists</span>
  <span class="hljs-keyword">if</span> (!__afl_area_ptr) { __afl_area_ptr = __afl_area_ptr_dummy; }

  <span class="hljs-keyword">char</span> *id_str = getenv(SHM_ENV_VAR);

  <span class="hljs-keyword">if</span> (__afl_final_loc) {

    <span class="hljs-comment">// adjust map_size by final_loc</span>
    __afl_map_size = __afl_final_loc + <span class="hljs-number">1</span>;  <span class="hljs-comment">// as we count starting 0</span>

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// remind to set larger MAP_SIZE</span>
    <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_SIZE) {

      <span class="hljs-keyword">char</span> *ptr;
      u32   val = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> ((ptr = getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>)) != <span class="hljs-literal">NULL</span>) { val = atoi(ptr); }
      <span class="hljs-keyword">if</span> (val &lt; __afl_final_loc) {

        <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_INITIAL_SIZE &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) {

          <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,
                  <span class="hljs-string">&quot;Warning: AFL++ tools might need to set AFL_MAP_SIZE to %u &quot;</span>
                  <span class="hljs-string">&quot;to be able to run this instrumented program if this &quot;</span>
                  <span class="hljs-string">&quot;crashes!\n&quot;</span>,
                  __afl_final_loc);

        }

      }

    }

  }

  <span class="hljs-comment">// check if disable sharedmem fuzzing</span>
  <span class="hljs-keyword">if</span> (__afl_sharedmem_fuzzing &amp;&amp; (!id_str || !getenv(SHM_FUZZ_ENV_VAR) ||
                                  fcntl(FORKSRV_FD, F_GETFD) == <span class="hljs-number">-1</span> ||
                                  fcntl(FORKSRV_FD + <span class="hljs-number">1</span>, F_GETFD) == <span class="hljs-number">-1</span>)) {

    <span class="hljs-comment">// ...</span>
    __afl_sharedmem_fuzzing = <span class="hljs-number">0</span>;

  }

  <span class="hljs-comment">// init map pointers </span>
  <span class="hljs-keyword">if</span> (!id_str) {

    u32 val = <span class="hljs-number">0</span>;
    u8 *ptr;

    <span class="hljs-keyword">if</span> ((ptr = getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>)) != <span class="hljs-literal">NULL</span>) { val = atoi(ptr); }

    <span class="hljs-keyword">if</span> (val &gt; MAP_INITIAL_SIZE &amp;&amp; val &gt; __afl_final_loc) {

      __afl_map_size = val;

    } <span class="hljs-keyword">else</span> {

      <span class="hljs-keyword">if</span> (__afl_first_final_loc &gt; MAP_INITIAL_SIZE) {

        <span class="hljs-comment">// done in second stage constructor</span>
        __afl_map_size = __afl_first_final_loc;

      } <span class="hljs-keyword">else</span> {

        __afl_map_size = MAP_INITIAL_SIZE;

      }

    }

    <span class="hljs-keyword">if</span> (__afl_map_size &gt; MAP_INITIAL_SIZE &amp;&amp; __afl_final_loc &lt; __afl_map_size) {

      __afl_final_loc = __afl_map_size;

    }

    <span class="hljs-comment">// ...</span>

  }

  <span class="hljs-comment">/* If we&apos;re running under AFL, attach to the appropriate region, replacing the
     early-stage __afl_area_initial region that is needed to allow some really
     hacky .init code to work correctly in projects such as OpenSSL. */</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// share memory mapping to fuzzer mmap</span>
  <span class="hljs-keyword">if</span> (id_str) {

    <span class="hljs-keyword">if</span> (__afl_area_ptr &amp;&amp; __afl_area_ptr != __afl_area_initial &amp;&amp;
        __afl_area_ptr != __afl_area_ptr_dummy) {

      <span class="hljs-keyword">if</span> (__afl_map_addr) {

        munmap((<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_final_loc);

      } <span class="hljs-keyword">else</span> {

        <span class="hljs-built_in">free</span>(__afl_area_ptr);

      }

      __afl_area_ptr = __afl_area_ptr_dummy;

    }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>    *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>            shm_fd = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *shm_base = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shm_open() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-comment">/* map the shared memory segment to the address space of the process */</span>
    <span class="hljs-keyword">if</span> (__afl_map_addr) {

      shm_base =
          mmap((<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_map_size, PROT_READ | PROT_WRITE,
               MAP_FIXED_NOREPLACE | MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);

    } <span class="hljs-keyword">else</span> {

      shm_base = mmap(<span class="hljs-number">0</span>, __afl_map_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                      shm_fd, <span class="hljs-number">0</span>);

    }

    close(shm_fd);
    shm_fd = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (shm_base == MAP_FAILED) {
      <span class="hljs-comment">// ...</span>
    }

    __afl_area_ptr = shm_base;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);

    <span class="hljs-keyword">if</span> (__afl_map_size &amp;&amp; __afl_map_size &gt; MAP_SIZE) {

      u8 *map_env = (u8 *)getenv(<span class="hljs-string">&quot;AFL_MAP_SIZE&quot;</span>);
      <span class="hljs-keyword">if</span> (!map_env || atoi((<span class="hljs-keyword">char</span> *)map_env) &lt; MAP_SIZE) {

        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;FS_ERROR_MAP_SIZE\n&quot;</span>);
        send_forkserver_error(FS_ERROR_MAP_SIZE);
        _exit(<span class="hljs-number">1</span>);

      }

    }

    __afl_area_ptr = (u8 *)shmat(shm_id, (<span class="hljs-keyword">void</span> *)__afl_map_addr, <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* Whooooops. */</span>
    <span class="hljs-comment">// ...</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    <span class="hljs-comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,
       our parent doesn&apos;t give up on us. */</span>
    <span class="hljs-comment">// write 1 into __afl_area_ptr[0] (shm[0]) to avoid being regarded as no coverage</span>
    __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((!__afl_area_ptr || __afl_area_ptr == __afl_area_initial) &amp;&amp;

             __afl_map_addr) {

    __afl_area_ptr = (u8 *)mmap(
        (<span class="hljs-keyword">void</span> *)__afl_map_addr, __afl_map_size, PROT_READ | PROT_WRITE,
        MAP_FIXED_NOREPLACE | MAP_SHARED | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (__afl_area_ptr == MAP_FAILED) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;can not acquire mmap for address %p\n&quot;</span>,
              (<span class="hljs-keyword">void</span> *)__afl_map_addr);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }
    <span class="hljs-comment">// if instrumentation needs more space to store then malloc larger area</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__afl_final_loc &gt; MAP_INITIAL_SIZE &amp;&amp;

             __afl_final_loc &gt; __afl_first_final_loc) {

    <span class="hljs-keyword">if</span> (__afl_area_initial != __afl_area_ptr_dummy) {

      <span class="hljs-built_in">free</span>(__afl_area_ptr_dummy);

    }

    __afl_map_size = __afl_final_loc + <span class="hljs-number">1</span>;
    __afl_area_ptr_dummy = (u8 *)<span class="hljs-built_in">malloc</span>(__afl_map_size);
    __afl_area_ptr = __afl_area_ptr_dummy;

    <span class="hljs-keyword">if</span> (!__afl_area_ptr_dummy) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,
              <span class="hljs-string">&quot;Error: AFL++ could not acquire %u bytes of memory, exiting!\n&quot;</span>,
              __afl_final_loc);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    }

  }  <span class="hljs-comment">// else: nothing to be done</span>

  __afl_area_ptr_backup = __afl_area_ptr;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">if</span> (__afl_selective_coverage) {

    <span class="hljs-keyword">if</span> (__afl_map_size &gt; MAP_INITIAL_SIZE) {

      __afl_area_ptr_dummy = (u8 *)<span class="hljs-built_in">malloc</span>(__afl_map_size);

    }

    <span class="hljs-keyword">if</span> (__afl_area_ptr_dummy) {

      <span class="hljs-keyword">if</span> (__afl_selective_coverage_start_off) {

        __afl_area_ptr = __afl_area_ptr_dummy;

      }

    } <span class="hljs-keyword">else</span> {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: __afl_selective_coverage failed!\n&quot;</span>);
      __afl_selective_coverage = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// continue;</span>

    }

  }

  <span class="hljs-comment">// share memory of comparing instruction log</span>
  id_str = getenv(CMPLOG_SHM_ENV_VAR);
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">if</span> (id_str) {

    <span class="hljs-comment">// /dev/null doesn&apos;t work so we use /dev/urandom</span>
    <span class="hljs-keyword">if</span> ((__afl_dummy_fd[<span class="hljs-number">1</span>] = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, O_WRONLY)) &lt; <span class="hljs-number">0</span>) {

      <span class="hljs-keyword">if</span> (pipe(__afl_dummy_fd) &lt; <span class="hljs-number">0</span>) { __afl_dummy_fd[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; }

    }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USEMMAP</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>     *shm_file_path = id_str;
    <span class="hljs-keyword">int</span>             shm_fd = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">struct</span> cmp_map *shm_base = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">/* create the shared memory segment as if it was a file */</span>
    shm_fd = shm_open(shm_file_path, O_RDWR, DEFAULT_PERMISSION);
    <span class="hljs-keyword">if</span> (shm_fd == <span class="hljs-number">-1</span>) {

      perror(<span class="hljs-string">&quot;shm_open() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);

    }

    <span class="hljs-comment">/* map the shared memory segment to the address space of the process */</span>
    shm_base = mmap(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cmp_map), PROT_READ | PROT_WRITE,
                    MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (shm_base == MAP_FAILED) {

      close(shm_fd);
      shm_fd = <span class="hljs-number">-1</span>;

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;mmap() failed\n&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);

    }

    __afl_cmp_map = shm_base;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    u32 shm_id = atoi(id_str);

    __afl_cmp_map = (<span class="hljs-keyword">struct</span> cmp_map *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    __afl_cmp_map_backup = __afl_cmp_map;

    <span class="hljs-keyword">if</span> (!__afl_cmp_map || __afl_cmp_map == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>) {

      perror(<span class="hljs-string">&quot;shmat for cmplog&quot;</span>);
      send_forkserver_error(FS_ERROR_SHM_OPEN);
      _exit(<span class="hljs-number">1</span>);

    }

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __AFL_CODE_COVERAGE</span>
  <span class="hljs-comment">// share memory of PCMAP (e.g. from PC to source code)</span>
  <span class="hljs-keyword">char</span> *pcmap_id_str = getenv(<span class="hljs-string">&quot;__AFL_PCMAP_SHM_ID&quot;</span>);

  <span class="hljs-keyword">if</span> (pcmap_id_str) {

    __afl_pcmap_size = __afl_map_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *);
    u32 shm_id = atoi(pcmap_id_str);

    __afl_pcmap_ptr = (<span class="hljs-keyword">uintptr_t</span> *)shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (__afl_debug) {

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;DEBUG: Received %p via shmat for pcmap\n&quot;</span>,
              __afl_pcmap_ptr);

    }

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// __AFL_CODE_COVERAGE</span></span>

  <span class="hljs-keyword">if</span> (!__afl_cmp_map &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_CMPLOG_DEBUG&quot;</span>)) {

    __afl_cmp_map_backup = __afl_cmp_map = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cmp_map));

  }

  <span class="hljs-comment">// adjust CMPLOG length</span>
  <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;AFL_CMPLOG_MAX_LEN&quot;</span>)) {

    <span class="hljs-keyword">int</span> tmp = atoi(getenv(<span class="hljs-string">&quot;AFL_CMPLOG_MAX_LEN&quot;</span>));
    <span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">16</span> &amp;&amp; tmp &lt;= <span class="hljs-number">32</span>) { __afl_cmplog_max_len = tmp; }

  }

}
</code></pre>
<h2 id="afl-llvm-passsocc">afl-llvm-pass.so.cc</h2>
<h3 id="aflcoverage">AFLCoverage</h3>
<pre><code class="lang-c"><span class="hljs-keyword">namespace</span> {

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
<span class="hljs-keyword">class</span> AFLCoverage : <span class="hljs-keyword">public</span> PassInfoMixin&lt;AFLCoverage&gt; { <span class="hljs-comment">// &lt;!&gt; core pass class for instrumentation</span>

 <span class="hljs-keyword">public</span>:
  AFLCoverage() {

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">class</span> AFLCoverage : <span class="hljs-keyword">public</span> ModulePass {

 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> ID;
  AFLCoverage() : ModulePass(ID) {

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    initInstrumentList(); <span class="hljs-comment">// init instrumentation allow/skip list</span>

  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
  <span class="hljs-function">PreservedAnalyses <span class="hljs-title">run</span><span class="hljs-params">(Module &amp;M, ModuleAnalysisManager &amp;MAM)</span></span>; <span class="hljs-comment">// entry function</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> override</span>; <span class="hljs-comment">// old entry function</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

 <span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">uint32_t</span>    ngram_size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ngram related</span>
  <span class="hljs-keyword">uint32_t</span>    ctx_k = <span class="hljs-number">0</span>; <span class="hljs-comment">// context related </span>
  <span class="hljs-keyword">uint32_t</span>    map_size = MAP_SIZE; <span class="hljs-comment">// map_size</span>
  <span class="hljs-keyword">uint32_t</span>    function_minimum_size = <span class="hljs-number">1</span>; <span class="hljs-comment">// function minimum size</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ctx_str = <span class="hljs-literal">NULL</span>, *caller_str = <span class="hljs-literal">NULL</span>, *skip_nozero = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// context related</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *use_threadsafe_counters = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// set threadsafe counters</span>

};

}  <span class="hljs-comment">// namespace</span>
</code></pre>
<h3 id="pass-register">Pass Register</h3>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 11                        <span class="hljs-comment">/* use new pass manager */</span></span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">LLVM_ATTRIBUTE_WEAK PassPluginLibraryInfo <span class="hljs-title">llvmGetPassPluginInfo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// use PassPluginLibraryInfo to register pass</span>
  <span class="hljs-keyword">return</span> {LLVM_PLUGIN_API_VERSION, <span class="hljs-string">&quot;AFLCoverage&quot;</span>, <span class="hljs-string">&quot;v0.1&quot;</span>,
          <span class="hljs-comment">/* lambda to insert our pass into the pass pipeline. */</span>
          [](PassBuilder &amp;PB) {

  #<span class="hljs-keyword">if</span> <span class="hljs-number">1</span>
    #<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &lt;= <span class="hljs-number">13</span>
            <span class="hljs-keyword">using</span> OptimizationLevel = <span class="hljs-keyword">typename</span> PassBuilder::OptimizationLevel; <span class="hljs-comment">// set optimization level</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 16</span>
      <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 20</span>
            PB.registerPipelineStartEPCallback( <span class="hljs-comment">// version 20+ register</span>
      #<span class="hljs-keyword">else</span>
            PB.registerOptimizerEarlyEPCallback( <span class="hljs-comment">// version 16-19 register</span>
      #endif
    #<span class="hljs-keyword">else</span>
            PB.registerOptimizerLastEPCallback( <span class="hljs-comment">// version 15- register</span>
    #endif
                [](ModulePassManager &amp;MPM, OptimizationLevel OL) {

                  MPM.addPass(AFLCoverage()); <span class="hljs-comment">// export pass AFLCoverage</span>

                });

  <span class="hljs-comment">/* TODO LTO registration */</span>
  #<span class="hljs-keyword">else</span>
    <span class="hljs-comment">// ...</span>

  #endif

          }}; <span class="hljs-comment">// return \{\{*}};</span>

} <span class="hljs-comment">// llvmGetPassPluginInfo</span>

#<span class="hljs-keyword">else</span>

<span class="hljs-keyword">char</span> AFLCoverage::ID = <span class="hljs-number">0</span>;
#endif
</code></pre>
<h3 id="instrumentation-main-function">Instrumentation &quot;Main Function&quot;</h3>
<pre><code class="lang-c">#if LLVM_VERSION_MAJOR &gt;= 11                        /* use new pass manager */
PreservedAnalyses AFLCoverage::run(Module &amp;M, ModuleAnalysisManager &amp;MAM) {

#else
bool AFLCoverage::runOnModule(Module &amp;M) {

#endif

  LLVMContext &amp;C = M.getContext();

  IntegerType *Int8Ty = IntegerType::getInt8Ty(C);
  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);
#ifdef AFL_HAVE_VECTOR_INTRINSICS
  IntegerType *IntLocTy =
      IntegerType::getIntNTy(C, sizeof(PREV_LOC_T) * CHAR_BIT);
#endif
  struct timeval  tv;
  struct timezone tz;
  u32             rand_seed;
  unsigned int    cur_loc = 0;

  /* Setup random() so we get Actually Random(TM) outputs from AFL_R() */
  gettimeofday(&amp;tv, &amp;tz);
  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();
  AFL_SR(rand_seed);

  /* Show a banner */

  setvbuf(stdout, NULL, _IONBF, 0);

  if (getenv(&quot;AFL_DEBUG&quot;)) debug = 1;

#if LLVM_VERSION_MAJOR &gt;= 11                        /* use new pass manager */
  if (getenv(&quot;AFL_SAN_NO_INST&quot;)) {

    if (debug) { fprintf(stderr, &quot;Instrument disabled\n&quot;); }
    return PreservedAnalyses::all();

  }

#else
  if (getenv(&quot;AFL_SAN_NO_INST&quot;)) {

    if (debug) { fprintf(stderr, &quot;Instrument disabled\n&quot;); }
    return true;

  }

#endif

  if ((isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) || getenv(&quot;AFL_DEBUG&quot;) != NULL) {

    SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST
              &quot; by &lt;lszekeres@google.com&gt; and &lt;adrian.herrera@anu.edu.au&gt;\n&quot;);

  } else

    be_quiet = 1;

  /*
    char *ptr;
    if ((ptr = getenv(&quot;AFL_MAP_SIZE&quot;)) || (ptr = getenv(&quot;AFL_MAPSIZE&quot;))) {

      map_size = atoi(ptr);
      if (map_size &lt; 8 || map_size &gt; (1 &lt;&lt; 29))
        FATAL(&quot;illegal AFL_MAP_SIZE %u, must be between 2^3 and 2^30&quot;,
    map_size); if (map_size % 8) map_size = (((map_size &gt;&gt; 3) + 1) &lt;&lt; 3);

    }

  */

  /* Decide instrumentation ratio */

  char        *inst_ratio_str = getenv(&quot;AFL_INST_RATIO&quot;);
  unsigned int inst_ratio = 100;

  if (inst_ratio_str) {

    if (sscanf(inst_ratio_str, &quot;%u&quot;, &amp;inst_ratio) != 1 || !inst_ratio ||
        inst_ratio &gt; 100)
      FATAL(&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;);

  }

#if LLVM_VERSION_MAJOR &lt; 9
  char *neverZero_counters_str = getenv(&quot;AFL_LLVM_NOT_ZERO&quot;);
#endif
  skip_nozero = getenv(&quot;AFL_LLVM_SKIP_NEVERZERO&quot;);
  use_threadsafe_counters = getenv(&quot;AFL_LLVM_THREADSAFE_INST&quot;);

  if ((isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) || !!getenv(&quot;AFL_DEBUG&quot;)) {

    if (use_threadsafe_counters) {

      // disabled unless there is support for other modules as well
      // (increases documentation complexity)
      /*      if (!getenv(&quot;AFL_LLVM_NOT_ZERO&quot;)) { */

      skip_nozero = &quot;1&quot;;
      SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST &quot; using thread safe counters\n&quot;);

      /*

            } else {

              SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST
                        &quot; using thread safe not-zero-counters\n&quot;);

            }

      */

    } else {

      SAYF(cCYA &quot;afl-llvm-pass&quot; VERSION cRST
                &quot; using non-thread safe instrumentation\n&quot;);

    }

  }

  unsigned PrevLocSize = 0;
  unsigned PrevCallerSize = 0;

  char *ngram_size_str = getenv(&quot;AFL_LLVM_NGRAM_SIZE&quot;);
  if (!ngram_size_str) ngram_size_str = getenv(&quot;AFL_NGRAM_SIZE&quot;);
  char *ctx_k_str = getenv(&quot;AFL_LLVM_CTX_K&quot;);
  if (!ctx_k_str) ctx_k_str = getenv(&quot;AFL_CTX_K&quot;);
  ctx_str = getenv(&quot;AFL_LLVM_CTX&quot;);
  caller_str = getenv(&quot;AFL_LLVM_CALLER&quot;);

  bool instrument_ctx = ctx_str || caller_str;

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  /* Decide previous location vector size (must be a power of two) */
  VectorType *PrevLocTy = NULL;

  if (ngram_size_str)
    if (sscanf(ngram_size_str, &quot;%u&quot;, &amp;ngram_size) != 1 || ngram_size &lt; 2 ||
        ngram_size &gt; NGRAM_SIZE_MAX)
      FATAL(
          &quot;Bad value of AFL_NGRAM_SIZE (must be between 2 and NGRAM_SIZE_MAX &quot;
          &quot;(%u))&quot;,
          NGRAM_SIZE_MAX);

  if (ngram_size == 1) ngram_size = 0;
  if (ngram_size)
    PrevLocSize = ngram_size - 1;
  else
    PrevLocSize = 1;

  /* Decide K-ctx vector size (must be a power of two) */
  VectorType *PrevCallerTy = NULL;

  if (ctx_k_str)
    if (sscanf(ctx_k_str, &quot;%u&quot;, &amp;ctx_k) != 1 || ctx_k &lt; 1 || ctx_k &gt; CTX_MAX_K)
      FATAL(&quot;Bad value of AFL_CTX_K (must be between 1 and CTX_MAX_K (%u))&quot;,
            CTX_MAX_K);

  if (ctx_k == 1) {

    ctx_k = 0;
    instrument_ctx = true;
    caller_str = ctx_k_str;  // Enable CALLER instead

  }

  if (ctx_k) {

    PrevCallerSize = ctx_k;
    instrument_ctx = true;

  }

#else
  if (ngram_size_str)
  #ifndef LLVM_VERSION_PATCH
    FATAL(
        &quot;Sorry, NGRAM branch coverage is not supported with llvm version &quot;
        &quot;%d.%d.%d!&quot;,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, 0);
  #else
    FATAL(
        &quot;Sorry, NGRAM branch coverage is not supported with llvm version &quot;
        &quot;%d.%d.%d!&quot;,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, LLVM_VERSION_PATCH);
  #endif
  if (ctx_k_str)
  #ifndef LLVM_VERSION_PATCH
    FATAL(
        &quot;Sorry, K-CTX branch coverage is not supported with llvm version &quot;
        &quot;%d.%d.%d!&quot;,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, 0);
  #else
    FATAL(
        &quot;Sorry, K-CTX branch coverage is not supported with llvm version &quot;
        &quot;%d.%d.%d!&quot;,
        LLVM_VERSION_MAJOR, LLVM_VERSION_MINOR, LLVM_VERSION_PATCH);
  #endif
  PrevLocSize = 1;
#endif

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  int PrevLocVecSize = PowerOf2Ceil(PrevLocSize);
  if (ngram_size)
    PrevLocTy = VectorType::get(IntLocTy, PrevLocVecSize
  #if LLVM_VERSION_MAJOR &gt;= 12
                                ,
                                false
  #endif
    );
#endif

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  int PrevCallerVecSize = PowerOf2Ceil(PrevCallerSize);
  if (ctx_k)
    PrevCallerTy = VectorType::get(IntLocTy, PrevCallerVecSize
  #if LLVM_VERSION_MAJOR &gt;= 12
                                   ,
                                   false
  #endif
    );
#endif

  /* Get globals for the SHM region and the previous location. Note that
     __afl_prev_loc is thread-local. */

  GlobalVariable *AFLMapPtr =
      new GlobalVariable(M, PointerType::get(Int8Ty, 0), false,
                         GlobalValue::ExternalLinkage, 0, &quot;__afl_area_ptr&quot;);
  GlobalVariable *AFLPrevLoc;
  GlobalVariable *AFLPrevCaller;
  GlobalVariable *AFLContext = NULL;

  if (ctx_str || caller_str)
#if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLContext = new GlobalVariable(
        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_ctx&quot;);
#else
    AFLContext = new GlobalVariable(
        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_ctx&quot;, 0,
        GlobalVariable::GeneralDynamicTLSModel, 0, false);
#endif

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  if (ngram_size)
  #if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevLoc = new GlobalVariable(
        M, PrevLocTy, /* isConstant */ false, GlobalValue::ExternalLinkage,
        /* Initializer */ nullptr, &quot;__afl_prev_loc&quot;);
  #else
    AFLPrevLoc = new GlobalVariable(
        M, PrevLocTy, /* isConstant */ false, GlobalValue::ExternalLinkage,
        /* Initializer */ nullptr, &quot;__afl_prev_loc&quot;,
        /* InsertBefore */ nullptr, GlobalVariable::GeneralDynamicTLSModel,
        /* AddressSpace */ 0, /* IsExternallyInitialized */ false);
  #endif
  else
#endif
#if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevLoc = new GlobalVariable(
        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;);
#else
  AFLPrevLoc = new GlobalVariable(
      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;, 0,
      GlobalVariable::GeneralDynamicTLSModel, 0, false);
#endif

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  if (ctx_k)
  #if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevCaller = new GlobalVariable(
        M, PrevCallerTy, /* isConstant */ false, GlobalValue::ExternalLinkage,
        /* Initializer */ nullptr, &quot;__afl_prev_caller&quot;);
  #else
    AFLPrevCaller = new GlobalVariable(
        M, PrevCallerTy, /* isConstant */ false, GlobalValue::ExternalLinkage,
        /* Initializer */ nullptr, &quot;__afl_prev_caller&quot;,
        /* InsertBefore */ nullptr, GlobalVariable::GeneralDynamicTLSModel,
        /* AddressSpace */ 0, /* IsExternallyInitialized */ false);
  #endif
  else
#endif
#if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
    AFLPrevCaller =
        new GlobalVariable(M, Int32Ty, false, GlobalValue::ExternalLinkage, 0,
                           &quot;__afl_prev_caller&quot;);
#else
  AFLPrevCaller = new GlobalVariable(
      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_caller&quot;,
      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);
#endif

#ifdef AFL_HAVE_VECTOR_INTRINSICS
  /* Create the vector shuffle mask for updating the previous block history.
     Note that the first element of the vector will store cur_loc, so just set
     it to undef to allow the optimizer to do its thing. */

  SmallVector&lt;Constant *, 32&gt; PrevLocShuffle = {UndefValue::get(Int32Ty)};

  for (unsigned I = 0; I &lt; PrevLocSize - 1; ++I)
    PrevLocShuffle.push_back(ConstantInt::get(Int32Ty, I));

  for (int I = PrevLocSize; I &lt; PrevLocVecSize; ++I)
    PrevLocShuffle.push_back(ConstantInt::get(Int32Ty, PrevLocSize));

  Constant *PrevLocShuffleMask = ConstantVector::get(PrevLocShuffle);

  Constant                   *PrevCallerShuffleMask = NULL;
  SmallVector&lt;Constant *, 32&gt; PrevCallerShuffle = {UndefValue::get(Int32Ty)};

  if (ctx_k) {

    for (unsigned I = 0; I &lt; PrevCallerSize - 1; ++I)
      PrevCallerShuffle.push_back(ConstantInt::get(Int32Ty, I));

    for (int I = PrevCallerSize; I &lt; PrevCallerVecSize; ++I)
      PrevCallerShuffle.push_back(ConstantInt::get(Int32Ty, PrevCallerSize));

    PrevCallerShuffleMask = ConstantVector::get(PrevCallerShuffle);

  }

#endif

  // other constants we need
  ConstantInt *One = ConstantInt::get(Int8Ty, 1);

  Value    *PrevCtx = NULL;     // CTX sensitive coverage
  LoadInst *PrevCaller = NULL;  // K-CTX coverage

  /* Instrument all the things! */

  int inst_blocks = 0;
  scanForDangerousFunctions(&amp;M);

  for (auto &amp;F : M) {

    int has_calls = 0;
    if (debug)
      fprintf(stderr, &quot;FUNCTION: %s (%zu)\n&quot;, F.getName().str().c_str(),
              F.size());

    if (!isInInstrumentList(&amp;F, MNAME)) { continue; }

    if (F.size() &lt; function_minimum_size) { continue; }

    std::list&lt;Value *&gt; todo;
    for (auto &amp;BB : F) {

      BasicBlock::iterator IP = BB.getFirstInsertionPt();
      IRBuilder&lt;&gt;          IRB(&amp;(*IP));

      // Context sensitive coverage
      if (instrument_ctx &amp;&amp; &amp;BB == &amp;F.getEntryBlock()) {

#ifdef AFL_HAVE_VECTOR_INTRINSICS
        if (ctx_k) {

          PrevCaller = IRB.CreateLoad(
  #if LLVM_VERSION_MAJOR &gt;= 14
              PrevCallerTy,
  #endif
              AFLPrevCaller);
          PrevCaller-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                  MDNode::get(C, None));
          PrevCtx =
              IRB.CreateZExt(IRB.CreateXorReduce(PrevCaller), IRB.getInt32Ty());

        } else

#endif
        {

          // load the context ID of the previous function and write to a
          // local variable on the stack
          LoadInst *PrevCtxLoad = IRB.CreateLoad(
#if LLVM_VERSION_MAJOR &gt;= 14
              IRB.getInt32Ty(),
#endif
              AFLContext);
          PrevCtxLoad-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                   MDNode::get(C, None));
          PrevCtx = PrevCtxLoad;

        }

        // does the function have calls? and is any of the calls larger than one
        // basic block?
        for (auto &amp;BB_2 : F) {

          if (has_calls) break;
          for (auto &amp;IN : BB_2) {

            CallInst *callInst = nullptr;
            if ((callInst = dyn_cast&lt;CallInst&gt;(&amp;IN))) {

              Function *Callee = callInst-&gt;getCalledFunction();
              if (!Callee || Callee-&gt;size() &lt; function_minimum_size)
                continue;
              else {

                has_calls = 1;
                break;

              }

            }

          }

        }

        // if yes we store a context ID for this function in the global var
        if (has_calls) {

          Value *NewCtx = ConstantInt::get(Int32Ty, AFL_R(map_size));
#ifdef AFL_HAVE_VECTOR_INTRINSICS
          if (ctx_k) {

            Value *ShuffledPrevCaller = IRB.CreateShuffleVector(
                PrevCaller, UndefValue::get(PrevCallerTy),
                PrevCallerShuffleMask);
            Value *UpdatedPrevCaller = IRB.CreateInsertElement(
                ShuffledPrevCaller, NewCtx, (uint64_t)0);

            StoreInst *Store =
                IRB.CreateStore(UpdatedPrevCaller, AFLPrevCaller);
            Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                               MDNode::get(C, None));

          } else

#endif
          {

            if (ctx_str) NewCtx = IRB.CreateXor(PrevCtx, NewCtx);
            StoreInst *StoreCtx = IRB.CreateStore(NewCtx, AFLContext);
            StoreCtx-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                  MDNode::get(C, None));

          }

        }

      }

      if (AFL_R(100) &gt;= inst_ratio) continue;

      /* Make up cur_loc */

      // cur_loc++;
      cur_loc = AFL_R(map_size);

/* There is a problem with Ubuntu 18.04 and llvm 6.0 (see issue #63).
   The inline function successors() is not inlined and also not found at runtime
   :-( As I am unable to detect Ubuntu18.04 here, the next best thing is to
   disable this optional optimization for LLVM 6.0.0 and Linux */
#if !(LLVM_VERSION_MAJOR == 6 &amp;&amp; LLVM_VERSION_MINOR == 0) || !defined __linux__
      // only instrument if this basic block is the destination of a previous
      // basic block that has multiple successors
      // this gets rid of ~5-10% of instrumentations that are unnecessary
      // result: a little more speed and less map pollution
      int more_than_one = -1;
      // fprintf(stderr, &quot;BB %u: &quot;, cur_loc);
      for (pred_iterator PI = pred_begin(&amp;BB), E = pred_end(&amp;BB); PI != E;
           ++PI) {

        BasicBlock *Pred = *PI;

        int count = 0;
        if (more_than_one == -1) more_than_one = 0;
        // fprintf(stderr, &quot; %p=&gt;&quot;, Pred);

        for (succ_iterator SI = succ_begin(Pred), E = succ_end(Pred); SI != E;
             ++SI) {

          BasicBlock *Succ = *SI;

          // if (count &gt; 0)
          //  fprintf(stderr, &quot;|&quot;);
          if (Succ != NULL) count++;
          // fprintf(stderr, &quot;%p&quot;, Succ);

        }

        if (count &gt; 1) more_than_one = 1;

      }

      // fprintf(stderr, &quot; == %d\n&quot;, more_than_one);
      if (F.size() &gt; 1 &amp;&amp; more_than_one != 1) {

        // in CTX mode we have to restore the original context for the caller -
        // she might be calling other functions which need the correct CTX
        if (instrument_ctx &amp;&amp; has_calls) {

          Instruction *Inst = BB.getTerminator();
          if (isa&lt;ReturnInst&gt;(Inst) || isa&lt;ResumeInst&gt;(Inst)) {

            IRBuilder&lt;&gt; Post_IRB(Inst);

            StoreInst *RestoreCtx;
  #ifdef AFL_HAVE_VECTOR_INTRINSICS
            if (ctx_k)
              RestoreCtx = IRB.CreateStore(PrevCaller, AFLPrevCaller);
            else
  #endif
              RestoreCtx = Post_IRB.CreateStore(PrevCtx, AFLContext);
            RestoreCtx-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                    MDNode::get(C, None));

          }

        }

        continue;

      }

#endif

      ConstantInt *CurLoc;

#ifdef AFL_HAVE_VECTOR_INTRINSICS
      if (ngram_size)
        CurLoc = ConstantInt::get(IntLocTy, cur_loc);
      else
#endif
        CurLoc = ConstantInt::get(Int32Ty, cur_loc);

      /* Load prev_loc */

      LoadInst *PrevLoc;

      if (ngram_size) {

        PrevLoc = IRB.CreateLoad(
#if LLVM_VERSION_MAJOR &gt;= 14
            PrevLocTy,
#endif
            AFLPrevLoc);

      } else {

        PrevLoc = IRB.CreateLoad(
#if LLVM_VERSION_MAJOR &gt;= 14
            IRB.getInt32Ty(),
#endif
            AFLPrevLoc);

      }

      PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));
      Value *PrevLocTrans;

#ifdef AFL_HAVE_VECTOR_INTRINSICS
      /* &quot;For efficiency, we propose to hash the tuple as a key into the
         hit_count map as (prev_block_trans &lt;&lt; 1) ^ curr_block_trans, where
         prev_block_trans = (block_trans_1 ^ ... ^ block_trans_(n-1)&quot; */

      if (ngram_size)
        PrevLocTrans =
            IRB.CreateZExt(IRB.CreateXorReduce(PrevLoc), IRB.getInt32Ty());
      else
#endif
        PrevLocTrans = PrevLoc;

      if (instrument_ctx)
        PrevLocTrans =
            IRB.CreateZExt(IRB.CreateXor(PrevLocTrans, PrevCtx), Int32Ty);
      else
        PrevLocTrans = IRB.CreateZExt(PrevLocTrans, IRB.getInt32Ty());

      /* Load SHM pointer */

      LoadInst *MapPtr = IRB.CreateLoad(
#if LLVM_VERSION_MAJOR &gt;= 14
          PointerType::get(Int8Ty, 0),
#endif
          AFLMapPtr);
      MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

      Value *MapPtrIdx;
#ifdef AFL_HAVE_VECTOR_INTRINSICS
      if (ngram_size)
        MapPtrIdx = IRB.CreateGEP(
            Int8Ty, MapPtr,
            IRB.CreateZExt(
                IRB.CreateXor(PrevLocTrans, IRB.CreateZExt(CurLoc, Int32Ty)),
                Int32Ty));
      else
#endif
        MapPtrIdx = IRB.CreateGEP(
#if LLVM_VERSION_MAJOR &gt;= 14
            Int8Ty,
#endif
            MapPtr, IRB.CreateXor(PrevLocTrans, CurLoc));

      /* Update bitmap */

      if (use_threadsafe_counters) {                              /* Atomic */

        IRB.CreateAtomicRMW(llvm::AtomicRMWInst::BinOp::Add, MapPtrIdx, One,
#if LLVM_VERSION_MAJOR &gt;= 13
                            llvm::MaybeAlign(1),
#endif
                            llvm::AtomicOrdering::Monotonic);
        /*

                }

        */

      } else {

        LoadInst *Counter = IRB.CreateLoad(
#if LLVM_VERSION_MAJOR &gt;= 14
            IRB.getInt8Ty(),
#endif
            MapPtrIdx);
        Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

        Value *Incr = IRB.CreateAdd(Counter, One);

#if LLVM_VERSION_MAJOR &gt;= 9
        if (!skip_nozero) {

#else
        if (neverZero_counters_str != NULL) {

#endif
          /* hexcoder: Realize a counter that skips zero during overflow.
           * Once this counter reaches its maximum value, it next increments to
           * 1
           *
           * Instead of
           * Counter + 1 -&gt; Counter
           * we inject now this
           * Counter + 1 -&gt; {Counter, OverflowFlag}
           * Counter + OverflowFlag -&gt; Counter
           */

          ConstantInt *Zero = ConstantInt::get(Int8Ty, 0);
          auto         cf = IRB.CreateICmpEQ(Incr, Zero);
          auto         carry = IRB.CreateZExt(cf, Int8Ty);
          Incr = IRB.CreateAdd(Incr, carry);

        }

        IRB.CreateStore(Incr, MapPtrIdx)
            -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

      }                                                  /* non atomic case */

      /* Update prev_loc history vector (by placing cur_loc at the head of the
         vector and shuffle the other elements back by one) */

      StoreInst *Store;

#ifdef AFL_HAVE_VECTOR_INTRINSICS
      if (ngram_size) {

        Value *ShuffledPrevLoc = IRB.CreateShuffleVector(
            PrevLoc, UndefValue::get(PrevLocTy), PrevLocShuffleMask);
        Value *UpdatedPrevLoc = IRB.CreateInsertElement(
            ShuffledPrevLoc, IRB.CreateLShr(CurLoc, (uint64_t)1), (uint64_t)0);

        Store = IRB.CreateStore(UpdatedPrevLoc, AFLPrevLoc);
        Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

      } else

#endif
      {

        Store = IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1),
                                AFLPrevLoc);
        Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

      }

      // in CTX mode we have to restore the original context for the caller -
      // she might be calling other functions which need the correct CTX.
      // Currently this is only needed for the Ubuntu clang-6.0 bug
      if (instrument_ctx &amp;&amp; has_calls) {

        Instruction *Inst = BB.getTerminator();
        if (isa&lt;ReturnInst&gt;(Inst) || isa&lt;ResumeInst&gt;(Inst)) {

          IRBuilder&lt;&gt; Post_IRB(Inst);

          StoreInst *RestoreCtx;
#ifdef AFL_HAVE_VECTOR_INTRINSICS
          if (ctx_k)
            RestoreCtx = IRB.CreateStore(PrevCaller, AFLPrevCaller);
          else
#endif
            RestoreCtx = Post_IRB.CreateStore(PrevCtx, AFLContext);
          RestoreCtx-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                  MDNode::get(C, None));

        }

      }

      inst_blocks++;

    }

#if 0
    if (use_threadsafe_counters) {                       /*Atomic NeverZero */
      // handle the list of registered blocks to instrument
      for (auto val : todo) {

        /* hexcoder: Realize a thread-safe counter that skips zero during
         * overflow. Once this counter reaches its maximum value, it next
         * increments to 1
         *
         * Instead of
         * Counter + 1 -&gt; Counter
         * we inject now this
         * Counter + 1 -&gt; {Counter, OverflowFlag}
         * Counter + OverflowFlag -&gt; Counter
         */

        /* equivalent c code looks like this
         * Thanks to
         https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/

            int old = atomic_load_explicit(&amp;Counter, memory_order_relaxed);
            int new;
            do {

                 if (old == 255) {

                   new = 1;

                 } else {

                   new = old + 1;

                 }

            } while (!atomic_compare_exchange_weak_explicit(&amp;Counter, &amp;old, new,

         memory_order_relaxed, memory_order_relaxed));

         */

        Value *              MapPtrIdx = val;
        Instruction *        MapPtrIdxInst = cast&lt;Instruction&gt;(val);
        BasicBlock::iterator it0(&amp;(*MapPtrIdxInst));
        ++it0;
        IRBuilder&lt;&gt; IRB(&amp;(*it0));

        // load the old counter value atomically
        LoadInst *Counter = IRB.CreateLoad(
  #if LLVM_VERSION_MAJOR &gt;= 14
        IRB.getInt8Ty(),
  #endif
        MapPtrIdx);
        Counter-&gt;setAlignment(llvm::Align());
        Counter-&gt;setAtomic(llvm::AtomicOrdering::Monotonic);
        Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

        BasicBlock *BB = IRB.GetInsertBlock();
        // insert a basic block with the corpus of a do while loop
        // the calculation may need to repeat, if atomic compare_exchange is not
        // successful

        BasicBlock::iterator it(*Counter);
        it++;  // split after load counter
        BasicBlock *end_bb = BB-&gt;splitBasicBlock(it);
        end_bb-&gt;setName(&quot;injected&quot;);

        // insert the block before the second half of the split
        BasicBlock *do_while_bb =
            BasicBlock::Create(C, &quot;injected&quot;, end_bb-&gt;getParent(), end_bb);

        // set terminator of BB from target end_bb to target do_while_bb
        auto term = BB-&gt;getTerminator();
        BranchInst::Create(do_while_bb, BB);
        term-&gt;eraseFromParent();

        // continue to fill instructions into the do_while loop
        IRB.SetInsertPoint(do_while_bb, do_while_bb-&gt;getFirstInsertionPt());

        PHINode *PN = IRB.CreatePHI(Int8Ty, 2);

        // compare with maximum value 0xff
        auto *Cmp = IRB.CreateICmpEQ(Counter, ConstantInt::get(Int8Ty, -1));

        // increment the counter
        Value *Incr = IRB.CreateAdd(Counter, One);

        // select the counter value or 1
        auto *Select = IRB.CreateSelect(Cmp, One, Incr);

        // try to save back the new counter value
        auto *CmpXchg = IRB.CreateAtomicCmpXchg(
            MapPtrIdx, PN, Select, llvm::AtomicOrdering::Monotonic,
            llvm::AtomicOrdering::Monotonic);
        CmpXchg-&gt;setAlignment(llvm::Align());
        CmpXchg-&gt;setWeak(true);
        CmpXchg-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));

        // get the result of trying to update the Counter
        Value *Success =
            IRB.CreateExtractValue(CmpXchg, ArrayRef&lt;unsigned&gt;({1}));
        // get the (possibly updated) value of Counter
        Value *OldVal =
            IRB.CreateExtractValue(CmpXchg, ArrayRef&lt;unsigned&gt;({0}));

        // initially we use Counter
        PN-&gt;addIncoming(Counter, BB);
        // on retry, we use the updated value
        PN-&gt;addIncoming(OldVal, do_while_bb);

        // if the cmpXchg was not successful, retry
        IRB.CreateCondBr(Success, end_bb, do_while_bb);

      }

    }

#endif

  }

  /*
    // This is currently disabled because we not only need to create/insert a
    // function (easy), but also add it as a constructor with an ID &lt; 5

    if (getenv(&quot;AFL_LLVM_DONTWRITEID&quot;) == NULL) {

      // yes we could create our own function, insert it into ctors ...
      // but this would be a pain in the butt ... so we use afl-llvm-rt.o

      Function *f = ...

      if (!f) {

        fprintf(stderr,
                &quot;Error: init function could not be created (this should not
    happen)\n&quot;); exit(-1);

      }

      ... constructor for f = 4

      BasicBlock *bb = &amp;f-&gt;getEntryBlock();
      if (!bb) {

        fprintf(stderr,
                &quot;Error: init function does not have an EntryBlock (this should
    not happen)\n&quot;); exit(-1);

      }

      BasicBlock::iterator IP = bb-&gt;getFirstInsertionPt();
      IRBuilder&lt;&gt;          IRB(&amp;(*IP));

      if (map_size &lt;= 0x800000) {

        GlobalVariable *AFLFinalLoc = new GlobalVariable(
            M, Int32Ty, true, GlobalValue::ExternalLinkage, 0,
            &quot;__afl_final_loc&quot;);
        ConstantInt *const_loc = ConstantInt::get(Int32Ty, map_size);
        StoreInst *  StoreFinalLoc = IRB.CreateStore(const_loc, AFLFinalLoc);
        StoreFinalLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;),
                                     MDNode::get(C, None));

      }

    }

  */

  /* Say something nice. */

  if (!be_quiet) {

    if (!inst_blocks)
      WARNF(&quot;No instrumentation targets found.&quot;);
    else {

      char modeline[100];
      snprintf(modeline, sizeof(modeline), &quot;%s%s%s%s%s%s&quot;,
               getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; : &quot;non-hardened&quot;,
               getenv(&quot;AFL_USE_ASAN&quot;) ? &quot;, ASAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_MSAN&quot;) ? &quot;, MSAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_CFISAN&quot;) ? &quot;, CFISAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_TSAN&quot;) ? &quot;, TSAN&quot; : &quot;&quot;,
               getenv(&quot;AFL_USE_UBSAN&quot;) ? &quot;, UBSAN&quot; : &quot;&quot;);
      OKF(&quot;Instrumented %d locations (%s mode, ratio %u%%).&quot;, inst_blocks,
          modeline, inst_ratio);

    }

  }

#if LLVM_VERSION_MAJOR &gt;= 11                        /* use new pass manager */
  return PreservedAnalyses();
#else
  return true;
#endif

}
</code></pre>
<h2 id="reference">Reference</h2>
<p>[1] <a href="https://github.com/AFLplusplus/AFLplusplus" target="_blank">https://github.com/AFLplusplus/AFLplusplus</a></p>
<p>[2] <a href="https://nyx-fuzz.com/papers/redqueen.pdf" target="_blank">https://nyx-fuzz.com/papers/redqueen.pdf</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="aflpp_src_reading_II.html" class="navigation navigation-prev " aria-label="Previous page: AFLpp Src Reading II - Forkserver">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="aflpp_new_test.html" class="navigation navigation-next " aria-label="Next page: AFL++ Add New Test">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"AFLpp Src Reading III - Instrumentation","level":"3.1.6","depth":2,"next":{"title":"AFL++ Add New Test","level":"3.1.7","depth":2,"path":"fuzzing/aflpp_new_test.md","ref":"fuzzing/aflpp_new_test.md","articles":[]},"previous":{"title":"AFLpp Src Reading II - Forkserver","level":"3.1.5","depth":2,"path":"fuzzing/aflpp_src_reading_II.md","ref":"fuzzing/aflpp_src_reading_II.md","articles":[]},"dir":"ltr"},"config":{"plugins":["theme-default","toggle-chapters","katex","sharing","lunr","search","livereload","fontsettings","highlight","theme-comscore"],"styles":{"website":"styles/website.css"},"pluginsConfig":{"livereload":{},"search":{},"lunr":{"ignoreSpecialCharacters":false,"maxIndexSize":1000000},"katex":{},"fontsettings":{"family":"sans","size":2,"theme":"white","fontFamily":"Arial Unicode MS"},"highlight":{},"theme-comscore":{},"sharing":{"all":["facebook","google","twitter","weibo","instapaper"],"facebook":true,"google":false,"instapaper":false,"twitter":true,"vk":false,"weibo":false},"theme-default":{"showLevel":false,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"toggle-chapters":{"toggle":true}},"theme":"default","author":"fa1c4","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"FA1C4 PATHs","language":"en","gitbook":"*","description":"Paths of fa1c4 to strive"},"file":{"path":"fuzzing/aflpp_src_reading_III.md","mtime":"2025-05-22T14:07:50.953Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-05-22T14:07:55.712Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-toggle-chapters/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

