---
title: "Glibc _IO_FILE Exploitation"
date: 2024-12-03
permalink: /gitbook/pwn/glibc_IO_FILE_exploitation/
tags:
  - pwn
  - _IO_FILE
---

# Glibc _IO_FILE Exploitation

在旧版的 glibc 中，`hook` 函数允许用户通过修改特定的符号（如 `__malloc_hook`, `__free_hook` 等）来拦截和定制 `malloc`, `free` 等内存管理函数的行为。这种机制通常用于实现自定义内存分配器、调试工具或其他高级功能。 

但从Glibc 2.34开始，`hook`被移除，开发者已经有了更好的方法来定制内存分配行为，如通过 `malloc` 相关的 API，或者通过 `LD_PRELOAD` 来替换函数。不过，这使得 glibc 上的利用变得更加复杂，原本通过打`__free_hook`等函数来 get shell 的利用链就失效了。但攻防是永远在迭代的，打 `_IO_FILE` 结构体的利用链就因此变得盛行起来 (2022+)。本篇主要研究和总结，作为当前版本的用户态 HEAP 主流漏洞利用链的核心之一的 `_IO_FILE` 的利用方法。

## Source Code

阅读源码是最核心的能力：[Glibc-2.35 _IO_FILE](https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/bits/types/struct_FILE.h#L35) <sup>[1]</sup> 

`_IO_FILE` 的定义，其中_IO\_read(write|buf)\_ptr(base|end)总共8个指针，用来控制输入输出缓冲区的操作，是IO过程必不可少的控制指针。

```c
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */ 
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

`_IO_FILE_complete` 的定义

```c
struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
```

`_IO_FILE_plus` 和 `_IO_jump_t` 的定义，其中每个函数的作用写在代码的注释部分 <sup>[2]</sup>

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy); // 1
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish); // 清空所有缓冲区，关闭（close）文件
    JUMP_FIELD(_IO_overflow_t, __overflow); // 当输出缓冲区用完时，向硬盘写入数据
    JUMP_FIELD(_IO_underflow_t, __underflow); // 从硬盘中读取数据，每次读取都是_IO_buf_base 至 _IO_buf_end。设置_IO_read_end为读取的总数
    JUMP_FIELD(_IO_underflow_t, __uflow); // 调用__underflow,增加检测逻辑
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail); // 设置存储
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn); // 将数据从source放入输出缓冲区, 程序的输出函数主要就是调用此函数
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn); // 将数据从输入缓冲区放入target, 程序的输入函数主要就是调用此函数
    JUMP_FIELD(_IO_seekoff_t, __seekoff); // 设置ptr指针
    JUMP_FIELD(_IO_seekpos_t, __seekpos); // 调用__seekoff
    JUMP_FIELD(_IO_setbuf_t, __setbuf); // 初始化各个缓冲区
    JUMP_FIELD(_IO_sync_t, __sync); // 负责与硬盘和缓冲区之间进行同步
    JUMP_FIELD(_IO_doallocate_t, __doallocate); // 申请缓冲区并初始化
    JUMP_FIELD(_IO_read_t, __read); // 最终输入, 封装的syscall_read
    JUMP_FIELD(_IO_write_t, __write); // 最终输出, 封装的syscall_write
    JUMP_FIELD(_IO_seek_t, __seek); // 调用__lseek64
    JUMP_FIELD(_IO_close_t, __close); // 关闭文件
    JUMP_FIELD(_IO_stat_t, __stat); // 获取文件描述符的状态, 调用__fxstat64
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc); // 无用, 返回-1
    JUMP_FIELD(_IO_imbue_t, __imbue); // 21
};

/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};
```



##  File Stream Oriented Programming (FSOP)

进程内所有的 \_IO_FILE 结构会使用 \_chain 域相互连接形成一个链表，这个链表的头部由\_IO_list_all 维护。FSOP 的核心思想就是劫持 \_IO_list_all 的值来伪造链表和其中的 \_IO_FILE 项，但是还需要某种方法进行触发。FSOP 选择的触发方法是调用 `_IO_flush_all_lockp`. 

`_IO_flush_all_lockp` 在三种情况会自动调用

> 1. 当 libc 执行 abort 流程时
> 2. 当执行 exit 函数时
> 3. 当执行流从 main 函数返回时

这个函数会刷新 \_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应会调用 `_IO_FILE_plus.vtable` 中的 `_IO_overflow`。

```c
int _IO_flush_all_lockp (int do_lock)
{
  int result = 0;
  struct _IO_FILE *fp;
  int last_stamp;
 
  fp = (_IO_FILE *) _IO_list_all;
  while (fp != NULL)
    {
        ...
      if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
       || (_IO_vtable_offset (fp) == 0
           && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr
                    > fp->_wide_data->_IO_write_base))
#endif
       )
      && _IO_OVERFLOW (fp, EOF) == EOF)   // 如果输出缓冲区有数据，刷新输出缓冲区
    result = EOF;
 
 
    fp = fp->_chain; //遍历链表
    }
...
}
```

### 虚表检查

版本差异

> 1. 2.23 的没有任何限制，可以将`vtable` 劫持在堆上并修改其内容，然后触发FSOP
> 2. 2.24 引入了`vtable check`，使得将 `vtable` 整体劫持到堆上已不可能，但可以使用内部 `vtable` 中`_IO_str_jumps` 或 `_IO_wstr_jumps` 来利用
> 3. 2.31 中将 `_IO_str_finish` 函数中强制执行 `free` 函数，导致无法使用之前的利用链
> 4. 2.37 重构...

虚表位置判断主要在 `IO_validate_vtable` 函数, 2.37之前的判断区间为 `_IO_helper_jumps - _IO_str_jumps` 之间的 0xd60 区域 

```c
_IO_helper_jumps
_IO_helper_jumps
_IO_cookie_jumps
_IO_proc_jumps
_IO_str_chk_jumps
_IO_wstrn_jumps
_IO_wstr_jumps
_IO_wfile_jumps_maybe_mmap
_IO_wfile_jumps_mmap
__GI__IO_wfile_jumps
_IO_wmem_jumps
_IO_mem_jumps
_IO_strn_jumps
_IO_obstack_jumps
_IO_file_jumps_maybe_mmap
_IO_file_jumps_mmap
__GI__IO_file_jumps
_IO_str_jumps
```

虚表检查函数 `_IO_vtable_check`, 同意开发者在外部重构 `vtable`，只是要满足一定条件

```c
void attribute_hidden _IO_vtable_check (void)
{
#ifdef SHARED
  /* Honor the compatibility flag.  */
  void (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables);
#ifdef PTR_DEMANGLE
  PTR_DEMANGLE (flag);
#endif
  if (flag == &_IO_vtable_check) // 检查是否是外部重构的 vtable
    return;
```

绕过虚表检查的三种方式, 需要有 ld 文件

> 1. 泄露 `ptr_guard`，反算 `IO_accept_foreign_vtables` 然后修改
> 2. 或者, 因为 `IO_accept_foreign_vtables` 中基本都是0，直接将 `ptr_guard` 修改为 `&_IO_vtable_check` 
> 3. `check_stdfiles_vtables` 函数是设置外置虚表的函数, 调用该函数可以绕过虚表检查
> 4. 2.37 没有加保护的 宽字符跳表

### 宽字符跳表

`house of apple` 和 `house of cat` 的利用链都有涉及未加保护的宽字符跳表, 其中只有4个会实际引用 (标注在注释部分)

```c
#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)
#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) // 1
#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)
#define _IO_WUFLOW(FP) WJUMP0 (__uflow, FP) // 2
#define _IO_WPBACKFAIL(FP, CH) WJUMP1 (__pbackfail, FP, CH)
#define _IO_WXSPUTN(FP, DATA, N) WJUMP2 (__xsputn, FP, DATA, N)
#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)
#define _IO_WSEEKOFF(FP, OFF, DIR, MODE) WJUMP3 (__seekoff, FP, OFF, DIR, MODE)
#define _IO_WSEEKPOS(FP, POS, FLAGS) WJUMP2 (__seekpos, FP, POS, FLAGS)
#define _IO_WSETBUF(FP, BUFFER, LENGTH) WJUMP2 (__setbuf, FP, BUFFER, LENGTH) // 3
#define _IO_WSYNC(FP) WJUMP0 (__sync, FP)
#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP) // 4
#define _IO_WSYSREAD(FP, DATA, LEN) WJUMP2 (__read, FP, DATA, LEN)
#define _IO_WSYSWRITE(FP, DATA, LEN) WJUMP2 (__write, FP, DATA, LEN)
#define _IO_WSYSSEEK(FP, OFFSET, MODE) WJUMP2 (__seek, FP, OFFSET, MODE)
#define _IO_WSYSCLOSE(FP) WJUMP0 (__close, FP)
#define _IO_WSYSSTAT(FP, BUF) WJUMP1 (__stat, FP, BUF)
#define _IO_WSHOWMANYC(FP) WJUMP0 (__showmanyc, FP)
#define _IO_WIMBUE(FP, LOCALE) WJUMP1 (__imbue, FP, LOCALE)
```



## House of Apple II 

直接使用适用性最广泛的 house <sup>[4]</sup> 利用链来作为 \_IO_FILE 利用的示例.

House of Apple II 的利用条件有三个

- 泄露 `heap` 地址和 `glibc` 地址
- 能控制程序执行 `IO` 操作，包括但不限于：从 `main` 函数返回、调用 `exit` 函数、通过 `__malloc_assert` 触发
- 能控制 `_IO_FILE` 的 `vtable` 和 `_wide_data` ( `largebin attack` )



涉及 `_wide_data` 结构, 给出对应源代码. 

```c
struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;    /* Current read pointer */
  wchar_t *_IO_read_end;    /* End of get area. */
  wchar_t *_IO_read_base;    /* Start of putback+get area. */
  wchar_t *_IO_write_base;    /* Start of put area. */
  wchar_t *_IO_write_ptr;    /* Current put pointer. */
  wchar_t *_IO_write_end;    /* End of put area. */
  wchar_t *_IO_buf_base;    /* Start of reserve area. */
  wchar_t *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */
  wchar_t *_IO_backup_base;    /* Pointer to first valid character of
                   backup area */
  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */
  
  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;
  wchar_t _shortbuf[1];
  const struct _IO_jump_t *_wide_vtable;
};
```

以 `vtable->_overflow` 调用为例，所用到的宏依次为

```c
#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)
 
#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)
 
#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)
 
#define _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)->_wide_vtable
```

利用链: 劫持 `IO_FILE` 的 `vtable` 为 `_IO_wfile_jumps` --> 控制 `_wide_data` 为可控的堆地址空间 --> 控制 `_wide_data->_wide_vtable` 为可控的堆地址空间 --> 控制程序执行 `IO` 流函数调用 --> 调用到 `_IO_W*` 函数即可控制程序的执行流。







## References

[1] https://elixir.bootlin.com/glibc/glibc-2.35/source

[2] https://bbs.kanxue.com/thread-275968.htm

[3] https://ctf-wiki.org/pwn/linux/user-mode/io-file/fsop/

[4] https://bbs.kanxue.com/thread-273832.htm
